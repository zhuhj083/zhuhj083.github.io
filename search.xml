<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dubbo源码分析2-EnableDubbo注解]]></title>
    <url>%2F2019%2F09%2F01%2Fdubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902_EnableDubbo%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一. EnableDubbo注解类分析首先看源码： 123456789101112131415161718192021222324252627282930/** * 发现EnableDubbo注解其实是EnableDubboConfig跟DubboComponentScan标签的合并 */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@EnableDubboConfig@DubboComponentScanpublic @interface EnableDubbo &#123; /** * 用于指定扫描那些包含@Service注解的包(声明后面提到Service注解都是Dubbo的Service注解) */ @AliasFor(annotation = DubboComponentScan.class, attribute = "basePackages") String[] scanBasePackages() default &#123;&#125;; /** * 用于指定扫描那些包含@service注解的类 */ @AliasFor(annotation = DubboComponentScan.class, attribute = "basePackageClasses") Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; /** * 表示是否绑定到多个bean。默认是true * 举例：作用是按照不同的配置文件格式进行选择。如：dubbo.application跟dubbo.applications之间的区别 */ @AliasFor(annotation = EnableDubboConfig.class, attribute = "multiple") boolean multipleConfig() default true;&#125; 我们发现EnableDubbo注解其实是EnableDubboConfig跟DubboComponentScan标签的合并，是一种简略写法。 所以我们再分别去分析EnableDubboConfig注解和DubboComponentScan注解]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo源码分析3-EnableDubboConfig注解分析]]></title>
    <url>%2F2019%2F09%2F01%2FDubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-EnableDubboConfig%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. EnableDubboConfig注解类分析1. EnableDubboConfig注解类首先来看EnableDubboConfig的源码 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented@Import(DubboConfigConfigurationRegistrar.class)public @interface EnableDubboConfig &#123; /** * It indicates whether binding to multiple Spring Beans. * * @return the default value is &lt;code&gt;false&lt;/code&gt; * @revised 2.5.9 */ boolean multiple() default true;&#125; 源码说明： 我们可以看到使用@Import注解引入了DubboConfigConfigurationRegistrar类，这个类实现了实现了ImportBeanDefinitionRegistrar接口，重写了接口的registerBeanDefinitions方法，这个方法返回类型是void，有一个BeanDefinitionRegistry类型的参数，允许我们直接通过BeanDefinitionRegistry注册bean。 2. DubboConfigConfigurationRegistrar类DubboConfigConfigurationRegistrar的源码 1234567891011121314151617181920212223public class DubboConfigConfigurationRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 从importingClassMetadata对象（这个对象中包含启动类上的标签和其他信息）中获取EnableDubboConfig标签中的属性， // 并保存在map中然后封装到AnnotationAttributes中 // AnnotationAttributes 是LinkedHashMap的子类 AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName())); //获取EnableDubboConfig标签中的multiple属性 boolean multiple = attributes.getBoolean("multiple"); // Single Config Bindings AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Single.class); if (multiple) &#123; // Since 2.6.6 https://github.com/apache/dubbo/issues/3193 AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, DubboConfigConfiguration.Multiple.class); &#125; &#125;&#125; 这里根据配置的multiple的值（默认为false），来注册dubboConfigConfiguration.Single 和dubboConfigConfiguration.Multiple Bean。我们看到是通过AnnotatedBeanDefinitionRegistryUtils类的registerBeans()方法来注册bean的。 3. AnnotatedBeanDefinitionRegistryUtils工具类AnnotatedBeanDefinitionRegistryUtils源码 123456789101112131415161718192021222324252627public abstract class AnnotatedBeanDefinitionRegistryUtils &#123; // ... 其他代码略，并删除了一切无关代码 public static void registerBeans(BeanDefinitionRegistry registry, Class&lt;?&gt;... annotatedClasses) &#123; if (ObjectUtils.isEmpty(annotatedClasses)) &#123; return; &#125; // 删除已注册的所有 注解类 // Remove all annotated-classes that have been registered Iterator&lt;Class&lt;?&gt;&gt; iterator = new ArrayList&lt;&gt;(asList(annotatedClasses)).iterator(); while (iterator.hasNext()) &#123; Class&lt;?&gt; annotatedClass = iterator.next(); if (isPresentBean(registry, annotatedClass)) &#123; iterator.remove(); &#125; &#125; // 获取AnnotatedBeanDefinitionReader对象，这个对面里面包含了所有的 注释后处理器, // 比如处理有Configuration标签的ConfigurationClassPostProcessor类 AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(registry); reader.register(annotatedClasses); &#125;&#125; 4. DubboConfigConfiguration.Single 内部类Single类源码 123456789101112131415161718/** * Single Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding */@EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.config-center", type = ConfigCenterBean.class), @EnableDubboConfigBinding(prefix = "dubbo.metadata-report", type = MetadataReportConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.metrics", type = MetricsConfig.class)&#125;)public static class Single &#123;&#125; 这类类上有注解@EnableDubboConfigBindings，以及@EnableDubboConfigBinging数组 5. EnableDubboConfigBindings注解类EnableDubboConfigBindings源码： 1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboConfigBindingsRegistrar.class)public @interface EnableDubboConfigBindings &#123; /** * The value of &#123;@link EnableDubboConfigBindings&#125; * * @return non-null */ EnableDubboConfigBinding[] value();&#125; 可以看到EnableDubboConfigBindings包含了 EnableDubboConfigBinding数组。并且用@Import 导入了DubboConfigBindingsRegistrar类， 6. DubboConfigBindingsRegistrar类12345678910111213141516171819202122public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //从importingClassMetadata对象获取EnableDubboConfigBindings注解的内容 AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName())); //从获取的attributes集合中找到value属性，此时value是一个EnableDubboConfigBinding注解数组 AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray("value"); //创建DubboConfigBindingRegistrar类，作用是注册EnableDubboConfigBinding注解中的Bean DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar(); registrar.setEnvironment(environment); for (AnnotationAttributes element : annotationAttributes) &#123; //遍历EnableDubboConfigBinding注解，并注册其中配置的各个config类。 registrar.registerBeanDefinitions(element, registry); &#125; &#125;&#125; DubboConfigBindingsRegistrar#registerBeanDefinitions()的主要作用就是拿到Single类上注解@EnableDubboConfigBindings所配置的@EnableDubboConfigBinding数组，再创建DubboConfigBindingRegistrar类，分别注册每个@EnableDubboConfigBinding配置的ConfigBean 7. EnableDubboConfigBinding注解类首先看EnableDubboConfigBinding源码，有2个属性prefix和type类。根据prefix 和type可以去properties配置文件中读取配置，在根据配置来注册ConfigBean 1234567891011121314@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(EnableDubboConfigBindings.class)@Import(DubboConfigBindingRegistrar.class)public @interface EnableDubboConfigBinding &#123; String prefix(); Class&lt;? extends AbstractConfig&gt; type(); boolean multiple() default false;&#125; 8. DubboConfigBindingRegistrar类最后是DubboConfigBindingRegistrar类。进入DubboConfigBindingRegistrar类中，对registerBeanDefinitions方法进行解析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName())); registerBeanDefinitions(attributes, registry); &#125; protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) &#123; // 获取EnableDubboConfigBinding注解中的prefix属性的占位符 // 例如prefix=dubbo.application则这里最后prefix值为dubbo.application String prefix = environment.resolvePlaceholders(attributes.getString("prefix")); // 获取EnableDubboConfigBinding注解中的type表示的对象的Class对象 Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass("type"); // 获取EnableDubboConfigBinding注解中的multiple属性 boolean multiple = attributes.getBoolean("multiple"); //注册Dubbo的ConfigBean registerDubboConfigBeans(prefix, configClass, multiple, registry); &#125; private void registerDubboConfigBeans(String prefix, Class&lt;? extends AbstractConfig&gt; configClass, boolean multiple, BeanDefinitionRegistry registry) &#123; // 获取环境变量中的所有属性，并找到前缀为prefix的所有的属性集合； // 例如 dubbo.application.name=dubbo-service，则properties中的值为 name：dubbo-service Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix); if (CollectionUtils.isEmpty(properties)) &#123; if (log.isDebugEnabled()) &#123; log.debug("There is no property for binding to dubbo config class [" + configClass.getName() + "] within prefix [" + prefix + "]"); &#125; return; &#125; // Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) : Collections.singleton(resolveSingleBeanName(properties, configClass, registry)); //遍历beanNames for (String beanName : beanNames) &#123; //使用beanName作为创建的configClass类型Bean的Name registerDubboConfigBean(beanName, configClass, registry); // 注册DubboConfigBindingBeanPostProcessor， // 这里使用BeanDefinitionBuilder来创建Bean，并将prefix跟beanName加到Bean的构造器参数列表中， // 这里会注册多个这个Bean只是构造参数不同 registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry); &#125; registerDubboConfigBeanCustomizers(registry); &#125; 通过简化为一个@EnableDubboConfig注解到配置类上，就完成了Dubbo主要的ConfigBean的Spring注入。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo源码分析4-DubboComponentScan注解分析]]></title>
    <url>%2F2019%2F09%2F01%2FDubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-DubboComponentScan%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一. DubboComponentScan注解类分析1. 首先看DubboComponentScan源码DubboComponentScan注解类 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(DubboComponentScanRegistrar.class)public @interface DubboComponentScan &#123; String[] value() default &#123;&#125;; String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; 看到@Import了DubboComponentScanRegistrar类。这个类也是实现了Spring的ImportBeanDefinitionRegistrar接口，直接看registerBeanDefinitions()方法 1234567891011121314@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 根据importingClassMetadata找到贴有DubboComponentScan注解的类的信息， // 从中获取需要扫描的包 Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata); // 注册ServiceAnnotationBeanPostProcessor，会传入packagesToScan registerServiceAnnotationBeanPostProcessor(packagesToScan, registry); // 注册ReferenceAnnotationBeanPostProcessor registerReferenceAnnotationBeanPostProcessor(registry);&#125; 上面的主要的工作就是对需要扫描的包或者类的处理，统一处理为包路径。然后注册两个Bean(ServiceAnnotationBeanPostProcessor和ReferenceAnnotationBeanPostProcessor) 2. ServiceAnnotationBeanPostProcessor分析ServiceAnnotationBeanPostProcessor实现了BeanDefinitionRegistryPostProcessor。 1234public class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware &#123; //...代码略&#125; ServiceAnnotationBeanPostProcessor的类图 BeanDefinitionRegistryPostProcessor的作用是：允许在正常的BeanFactoryPostProcessor检测开始之前注册更多的自定义bean。 Spring容器中所有的Bean注册之后，回调postProcessBeanDefinitionRegistry方法，开始扫描@Service注解并注入容器。 看ServiceAnnotationBeanPostProcessor#postProcessBeanDefinitionRegistry方法。 12345678910111213141516@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; //// 获取扫描包，扫描包可以是多个，所以这里使用了Set集合 Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan); // 判断需要扫描的包是否为空 if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123; // 不为空则调用方法进行解析 registerServiceBeans(resolvedPackagesToScan, registry); &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn("packagesToScan is empty , ServiceBean registry will be ignored!"); &#125; &#125;&#125; 继续看ServiceAnnotationBeanPostProcessor#registerServiceBeans方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Registers Beans whose classes was annotated &#123;@link Service&#125; * * @param packagesToScan The base packages to scan * @param registry &#123;@link BeanDefinitionRegistry&#125; */private void registerServiceBeans(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry) &#123; //定义扫描对象，该类继承了ClassPathBeanDefinitionScanner类 DubboClassPathBeanDefinitionScanner scanner = new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader); // beanName解析器 BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry); scanner.setBeanNameGenerator(beanNameGenerator); //这行代码很重要，添加了一个注解过滤器，用来过滤出来写了@Service注解的对象 scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); /** * 添加旧版Dubbo @Service的兼容性 * * Add the compatibility for legacy Dubbo's @Service * * The issue : https://github.com/apache/dubbo/issues/4330 * @since 2.7.3 */ scanner.addIncludeFilter(new AnnotationTypeFilter(com.alibaba.dubbo.config.annotation.Service.class)); //扫描正式开始，遍历包 for (String packageToScan : packagesToScan) &#123; // Registers @Service Bean first scanner.scan(packageToScan); // 开始查找添加了@Service注解的类 // Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not. Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator); //找到了则不为空 if (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123; for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123; // 注册serviceBean定义，并做数据绑定和解析 registerServiceBean(beanDefinitionHolder, registry, scanner); &#125; if (logger.isInfoEnabled()) &#123; logger.info(beanDefinitionHolders.size() + " annotated Dubbo's @Service Components &#123; " + beanDefinitionHolders + " &#125; were scanned under package[" + packageToScan + "]"); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn("No Spring Bean annotating Dubbo's @Service was found under package[" + packageToScan + "]"); &#125; &#125; &#125;&#125; 上面的代码，主要作用就是通过扫描过滤器，扫描包中添加了@Service注解的类。最后得到BeanDefinitionHolder对象，调用registerServiceBean来注册ServiceBean 看registerServiceBean方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Registers &#123;@link ServiceBean&#125; from new annotated &#123;@link Service&#125; &#123;@link BeanDefinition&#125; * * @param beanDefinitionHolder * @param registry * @param scanner * @see ServiceBean * @see BeanDefinition */private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry, DubboClassPathBeanDefinitionScanner scanner) &#123; // 有@Service注解的，实现了某个接口的 服务类对象 Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder); // 找到@service注解 Annotation service = findServiceAnnotation(beanClass); /** * The &#123;@link AnnotationAttributes&#125; of @Service annotation */ AnnotationAttributes serviceAnnotationAttributes = getAnnotationAttributes(service, false, false); // 服务类实现的接口对象 Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(serviceAnnotationAttributes, beanClass); // 得到bean的名称 String annotatedServiceBeanName = beanDefinitionHolder.getBeanName(); // 构建ServiceBean对象的BeanDefinition,通过Service注解对象，以及接口服务的实现类生成ServiceBean AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, serviceAnnotationAttributes, interfaceClass, annotatedServiceBeanName); // 构建ServuceBean的名称 // ServiceBean Bean name String beanName = generateServiceBeanName(serviceAnnotationAttributes, interfaceClass); // 校验Bean是否重复 if (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; // check duplicated candidate bean // 调用BeanDefinitionRegistry注册。 registry.registerBeanDefinition(beanName, serviceBeanDefinition); if (logger.isInfoEnabled()) &#123; logger.info("The BeanDefinition[" + serviceBeanDefinition + "] of ServiceBean has been registered with name : " + beanName); &#125; &#125; else &#123; if (logger.isWarnEnabled()) &#123; logger.warn("The Duplicated BeanDefinition[" + serviceBeanDefinition + "] of ServiceBean[ bean name : " + beanName + "] was be found , Did @DubboComponentScan scan to same package in many times?"); &#125; &#125;&#125; 最后看buildServiceBeanDefinition方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899private AbstractBeanDefinition buildServiceBeanDefinition(Annotation serviceAnnotation, AnnotationAttributes serviceAnnotationAttributes, Class&lt;?&gt; interfaceClass, String annotatedServiceBeanName) &#123; // 生成ServiceBean对象BeanDefinitionBuilder BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class); // 获取beanDefinition AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 属性集合 MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); // 忽略的属性,指的是AnnotationPropertyValuesAdapter中，不把以下属性放到PropertyValues中去 String[] ignoreAttributeNames = of("provider", "monitor", "application", "module", "registry", "protocol", "interface", "interfaceName", "parameters"); propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(serviceAnnotation, environment, ignoreAttributeNames)); //// 设置ref属性 // References "ref" property to annotated-@Service Bean addPropertyReference(builder, "ref", annotatedServiceBeanName); // 设置服务的接口 // Set interface builder.addPropertyValue("interface", interfaceClass.getName()); // Convert parameters into map builder.addPropertyValue("parameters", convertParameters(serviceAnnotationAttributes.getStringArray("parameters"))); // Add methods parameters List&lt;MethodConfig&gt; methodConfigs = convertMethodConfigs(serviceAnnotationAttributes.get("methods")); if (!methodConfigs.isEmpty()) &#123; builder.addPropertyValue("methods", methodConfigs); &#125; /** * 获取注解中的provider属性 * Add &#123;@link org.apache.dubbo.config.ProviderConfig&#125; Bean reference */ String providerConfigBeanName = serviceAnnotationAttributes.getString("provider"); if (StringUtils.hasText(providerConfigBeanName)) &#123; addPropertyReference(builder, "provider", providerConfigBeanName); &#125; /** * 获取注解中的monitor属性 * Add &#123;@link org.apache.dubbo.config.MonitorConfig&#125; Bean reference */ String monitorConfigBeanName = serviceAnnotationAttributes.getString("monitor"); if (StringUtils.hasText(monitorConfigBeanName)) &#123; addPropertyReference(builder, "monitor", monitorConfigBeanName); &#125; /** * 获取注解中的application属性 * Add &#123;@link org.apache.dubbo.config.ApplicationConfig&#125; Bean reference */ String applicationConfigBeanName = serviceAnnotationAttributes.getString("application"); if (StringUtils.hasText(applicationConfigBeanName)) &#123; addPropertyReference(builder, "application", applicationConfigBeanName); &#125; /** * Add &#123;@link org.apache.dubbo.config.ModuleConfig&#125; Bean reference */ String moduleConfigBeanName = serviceAnnotationAttributes.getString("module"); if (StringUtils.hasText(moduleConfigBeanName)) &#123; addPropertyReference(builder, "module", moduleConfigBeanName); &#125; /** * 获取注解中的注册中心属性 * Add &#123;@link org.apache.dubbo.config.RegistryConfig&#125; Bean reference */ String[] registryConfigBeanNames = serviceAnnotationAttributes.getStringArray("registry"); List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames); if (!registryRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue("registries", registryRuntimeBeanReferences); &#125; /** * 获取注解中的协议属性 * Add &#123;@link org.apache.dubbo.config.ProtocolConfig&#125; Bean reference */ String[] protocolConfigBeanNames = serviceAnnotationAttributes.getStringArray("protocol"); List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames); if (!protocolRuntimeBeanReferences.isEmpty()) &#123; builder.addPropertyValue("protocols", protocolRuntimeBeanReferences); &#125; return builder.getBeanDefinition();&#125; 最终dubbo解析出了ServiceBean对象的beandefinition放入了spring的容器。 ServiceBean对于每个暴露的服务来说很重要，每个暴露的服务都拥有一个ServiceBean，这个类里面包含了服务发布，服务下线等操作，算是一个很核心的类。 3. ReferenceAnnotationBeanPostProcessor分析Dubbo中做属性注入是通过ReferenceAnnotationBeanPostProcessor处理的，主要做以下几件事情 获取类中标注的@Reference注解的字段和方法 反射设置字段或方法对应的引用 3.1 类的继承关系12345678public class ReferenceAnnotationBeanPostProcessor extends AnnotationInjectedBeanPostProcessor implements ApplicationContextAware, ApplicationListener &#123;&#125;public abstract class AnnotationInjectedBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware, BeanClassLoaderAware, EnvironmentAware, DisposableBean &#123;&#125; ReferenceAnnotationBeanPostProcessor是一个BeanPostProcessor，该类实现了InstantiationAwareBeanPostProcessor ，所以Spring的Bean中初始化前会触发postProcessPropertyValues方法，该方法允许我们做进一步处理，比如增加属性和属性值修改等。从而达到解析@Reference并实现依赖注入（@Autowired注入一样的原理）。 InstantiationAwareBeanPostProcessor：实例化Bean后置处理器（继承BeanPostProcessor），有以下三个方法 postProcessBeforeInstantiation：在实例化目标对象之前执行，可以自定义实例化逻辑，如返回一个代理对象等。 postProcessAfterInitialization： Bean实例化完毕后执行的后处理操作，所有初始化逻辑、装配逻辑之前执行，如果返回false将阻止其他的InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation的执行。 postProcessPropertyValues：完成其他定制的一些依赖注入和依赖检查等，如： AutowiredAnnotationBeanPostProcessor执行@Autowired注解注入 CommonAnnotationBeanPostProcessor执行@Resource等注解的注入 RequiredAnnotationBeanPostProcessor执行@ Required注解的检查等等。 3.2 源码分析首先看AnnotationInjectedBeanPostProcessor#postProcessPropertyValues方法 1234567891011121314151617181920@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123; // InjectionMetadata metadata是注入元数据 ，包含了 // 目标Bean的Class对象 // 和注入元素（InjectionElement）的集合 // 查找Bean所有标注了指定注解（@Reference）的字段和方法 InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs); try &#123; // 通过反射来给bean设置值 metadata.inject(bean, beanName, pvs); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, "Injection of @" + getAnnotationType().getSimpleName() + " dependencies is failed", ex); &#125; return pvs;&#125; 注入元数据InjectionMetadata类 12345678910111213141516public class InjectionMetadata &#123; //目标Bean的Class对象 private final Class&lt;?&gt; targetClass; //注入元素（InjectionElement）集合 //注入元素可能是属性也可能是方法 private final Collection&lt;InjectedElement&gt; injectedElements; public InjectionMetadata(Class&lt;?&gt; targetClass, Collection&lt;InjectedElement&gt; elements) &#123; this.targetClass = targetClass; this.injectedElements = elements; &#125; //...其他代码略&#125; 3.2.1 收集注入元数据通过findInjectionMetadata找到@Reference，并解析得到 元数据对象。 AnnotationInjectedBeanPostProcessor#findInjectionMetadata() 12345678910111213141516171819202122232425262728293031323334private InjectionMetadata findInjectionMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) &#123; // 通过类名作为缓存的key // Fall back to class name as cache key, for backwards compatibility with custom callers. String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // 从缓存中的injectionMetadataCache根据类名获取 AnnotatedInjectionMetadata元数据 // Quick check on the concurrent map first, with minimal locking. AnnotationInjectedBeanPostProcessor.AnnotatedInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); // 判断metadata是否需要刷新（metadata为空以及class对象不等于ReferenceInjectionMetadata时，则需要进行刷新） if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; synchronized (this.injectionMetadataCache) &#123; metadata = this.injectionMetadataCache.get(cacheKey); // 双重检查机制 if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; if (metadata != null) &#123; metadata.clear(pvs); &#125; try &#123; // 构建InjectionMetadata元数据 metadata = buildAnnotatedMetadata(clazz); // 加入到缓存 this.injectionMetadataCache.put(cacheKey, metadata); &#125; catch (NoClassDefFoundError err) &#123; throw new IllegalStateException("Failed to introspect object class [" + clazz.getName() + "] for annotation metadata: could not find class that it depends on", err); &#125; &#125; &#125; &#125; return metadata;&#125; 构建InjectionMetadata元数据， AnnotationInjectedBeanPostProcessor#buildAnnotatedMetadata()方法源码： 1234567891011private AnnotationInjectedBeanPostProcessor.AnnotatedInjectionMetadata buildAnnotatedMetadata(final Class&lt;?&gt; beanClass) &#123; // 获取属性上的指定注解（@Reference注解） Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements = findFieldAnnotationMetadata(beanClass); // 获取方法上的指定注解（@Reference注解） Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedMethodElement&gt; methodElements = findAnnotatedMethodMetadata(beanClass); return new AnnotationInjectedBeanPostProcessor.AnnotatedInjectionMetadata(beanClass, fieldElements, methodElements);&#125; 获取属性上的@Reference注解详解 AnnotationInjectedBeanPostProcessor#findFieldAnnotationMetadata()方法源码： 1234567891011121314151617181920212223242526272829private List&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; findFieldAnnotationMetadata(final Class&lt;?&gt; beanClass) &#123; final List&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; elements = new LinkedList&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt;(); ReflectionUtils.doWithFields(beanClass, field -&gt; &#123; // getAnnotationTypes 拿到需要寻找的注解类（@Reference注解） for (Class&lt;? extends Annotation&gt; annotationType : getAnnotationTypes()) &#123; //合并和解析占位符后，获取AnnotationAttributes注释属性 AnnotationAttributes attributes = getMergedAttributes(field, annotationType, getEnvironment(), true); if (attributes != null) &#123; // 不能是static方法 if (Modifier.isStatic(field.getModifiers())) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("@" + annotationType.getName() + " is not supported on static fields: " + field); &#125; return; &#125; elements.add(new AnnotatedFieldElement(field, attributes)); &#125; &#125; &#125;); return elements;&#125; 3.2.2 对字段、方法进行反射绑定元数据收集好了，接下来就是调用metadata.inject(bean, beanName, pvs);这个方法了。 12345678910111213public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable &#123; // 获取metadata中的InjectedElement Collection&lt;InjectedElement&gt; elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) &#123; boolean debug = logger.isDebugEnabled(); // 循环设值 for (InjectedElement element : elementsToIterate) &#123; //触发方法或字段值的注入 element.inject(target, beanName, pvs); &#125; &#125;&#125; InjectionMetadata#inject()方法 1234567891011121314151617181920protected void inject(Object target, String requestingBeanName, PropertyValues pvs) throws Throwable &#123; if (this.isField) &#123; Field field = (Field) this.member; ReflectionUtils.makeAccessible(field); field.set(target, getResourceToInject(target, requestingBeanName)); &#125; else &#123; if (checkPropertySkipping(pvs)) &#123; return; &#125; try &#123; Method method = (Method) this.member; ReflectionUtils.makeAccessible(method); method.invoke(target, getResourceToInject(target, requestingBeanName)); &#125; catch (InvocationTargetException ex) &#123; throw ex.getTargetException(); &#125; &#125;&#125; 属性注入： 12345678910111213141516171819202122232425262728public class AnnotatedFieldElement extends InjectionMetadata.InjectedElement &#123; private final Field field; private final AnnotationAttributes attributes; private volatile Object bean; protected AnnotatedFieldElement(Field field, AnnotationAttributes attributes) &#123; super(field, null); this.field = field; this.attributes = attributes; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; Class&lt;?&gt; injectedType = field.getType(); Object injectedObject = getInjectedObject(attributes, bean, beanName, injectedType, this); ReflectionUtils.makeAccessible(field); field.set(bean, injectedObject); &#125;&#125; 方法注入： 12345678910111213141516171819202122232425262728private class AnnotatedMethodElement extends InjectionMetadata.InjectedElement &#123; private final Method method; private final AnnotationAttributes attributes; private volatile Object object; protected AnnotatedMethodElement(Method method, PropertyDescriptor pd, AnnotationAttributes attributes) &#123; super(method, pd); this.method = method; this.attributes = attributes; &#125; @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; Class&lt;?&gt; injectedType = pd.getPropertyType(); Object injectedObject = getInjectedObject(attributes, bean, beanName, injectedType, this); ReflectionUtils.makeAccessible(method); method.invoke(bean, injectedObject); &#125;&#125; 消费者每引用的一种服务，都会创建一个ReferenceBean， 如果多个地方使用@Reference引用同一个服务，需要看他们的的缓存key是否一样，如果都是一样的，那么就只会创建一个ReferenceBean，如果有些配置不一样，比如版本号不一致，则会创建创建不同的ReferenceBean对象，这也是他版本号能够起到的作用把。至此@Reference注解已经解析完毕，并且服务引用的对象也已经创建了。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析5-ResolvableType]]></title>
    <url>%2F2019%2F09%2F01%2FSpring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-ResolvableType%2F</url>
    <content type="text"><![CDATA[待完成]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析3-DefaultSingletonBeanRegistry]]></title>
    <url>%2F2019%2F08%2F31%2FSpring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-DefaultSingletonBeanRegistry%2F</url>
    <content type="text"><![CDATA[DefaultSingletonBeanRegistry类 继承SimpleAliasRegistry——主要实现了对单例Bean的注册和获取 实现了SingletonBeanRegistry接口——具有对alias的简单增删改查等功能 1.DefaultSingletonBeanRegistry的继承关系图DefaultSingletonBeanRegistry类继承关系 DefaultSingletonBeanRegistry类图 如果所示DefaultSingletonBeanRegistry继承SimpleAliasRegistry类和实现了SingletonBeanRegistry接口。 因此这个类可以有别名注册的功能和单例bean注册的功能，并且他还支持注册DisposableBean实例 它依赖ObjectFactory接口和DisposableBean接口(关闭注册表时调用到了destroy方法)。 ObjectFactory : 这个接口通常用于封装一个通用的工厂，它只有一个方法getObject() ，它调用getObject()方法返回一个新的实例，一些在每次调用的目标对象（原型）. DisposableBean : 接口实现为beans要销毁释放资源。只有一个方法destroy()，由一个破坏一个singleton的BeanFactory调用。 2. 父接口与父类2.1 AliasRegiser接口1234567891011121314151617181920212223242526272829package org.springframework.core;/** * 管理别名的通用接口，是BeanDefinitionRegistry的父接口 * @since 2.5.2 */public interface AliasRegistry &#123; /** * 给定 名称，为其注册别名。 */ void registerAlias(String name, String alias); /** * 从 registry 中删除指定的别名。 */ void removeAlias(String alias); /** * 确定此 给定名称 是否定义为别名 */ boolean isAlias(String name); /** * 返回给定名称的别名的数组 */ String[] getAliases(String name);&#125; 2.2 SimpleAliasRegistry类SimpleAliasRegistry实现了AliasRegistry。使用一个map作为别名的缓存 1234567public class SimpleAliasRegistry implements AliasRegistry &#123; //map作为缓存，key为alias，value为name /** Map from alias to canonical name. */ private final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap&lt;&gt;(16); // ... 其他代码略 &#125; 2.3 SingletonBeanRegistry接口定义对单例的注册及获取 1234567891011121314151617181920212223242526272829public interface SingletonBeanRegistry &#123; /** * 在bean registry（注册器）中以给定的名字注册现有的对象为单例 * 这个对象应该完全被初始化了，注册器不会执行它的任何初始化回调（例如：afterPropertiesSet方法） * 也不会收到任何销毁函数的回调（destroy method）。 */ @Nullable Object getSingleton(String beanName); boolean containsSingleton(String beanName); /** * 返回所有的已经注册的单例名字 */ String[] getSingletonNames(); /** * 返回注册的单例个数 */ int getSingletonCount(); /** * mutex：互斥 * 返回此注册表使用的单例互斥锁 * @since 4.2 */ Object getSingletonMutex();&#125; DefaultSingletonBeanRegistry源码注释 DefaultSingletonBeanRegistry分析： 主要通过几个缓存来完成单例bean的注册与获取 3个主要map singletonObjects：存放singleton对象的缓存 singletonFactories：是存放生产singleton的工厂对象的缓存 earlySingletonObjects：是存放singletonFactory 制造出来的 singleton 的缓存，然后由 registeredSingletons 注册表 各个SingletonObject之间的关系 containedBeanMap：bean的包含关系 dependentBeanMap：被依赖关系，当前bean被Set\&lt;String>里的bean依赖 dependenciesForBeanMap：依赖关系:当前bean依赖的Set\&lt;String> disposableBeans存放一次性bean的缓存 在注册两个bean包含关系的时候，同时要注册他们的依赖关系。 源码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123; // 存放singleton对象的缓存 /** Cache of singleton objects: bean name to bean instance. */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); // 是存放生产singleton的工厂对象的缓存 /** Cache of singleton factories: bean name to ObjectFactory. */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16); // 是存放singletonFactory 制造出来的 singleton 的缓存 /** Cache of early singleton objects: bean name to bean instance. */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16); /** * 单例注册表 */ /** Set of registered singletons, containing the bean names in registration order. */ private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;&gt;(256); // 以上四个缓存是这个类存放单例bean的主要Map // 目前正在创建中的单例bean的名字的集合 /** Names of beans that are currently in creation. */ private final Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16)); // 创建检查排除 的bean的名字集合。 /** Names of beans currently excluded from in creation checks. */ private final Set&lt;String&gt; inCreationCheckExclusions = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16)); // 存放异常出现的相关的原因的集合 /** List of suppressed Exceptions, available for associating related causes. */ @Nullable private Set&lt;Exception&gt; suppressedExceptions; // 标志，指示我们目前是否在销毁单例中 /** Flag that indicates whether we're currently within destroySingletons. */ private boolean singletonsCurrentlyInDestruction = false; // 存放一次性bean的缓存 /** Disposable bean instances: bean name to disposable instance. */ private final Map&lt;String, Object&gt; disposableBeans = new LinkedHashMap&lt;&gt;(); // 外部bean与被包含在外部bean的所有内部bean集合包含关系的缓存 /** Map between containing bean names: bean name to Set of bean names that the bean contains. */ private final Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = new ConcurrentHashMap&lt;&gt;(16); // dependentBeanMap存放的是 依赖当前bean的 所有的bean的集合 /** Map between dependent bean names: bean name to Set of dependent bean names. */ private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = new ConcurrentHashMap&lt;&gt;(64); // dependenciesForBeanMap中存放的则是 当前Bean所依赖的Bean的集合。 // 当前bean的 beanName 在Set里面 /** Map between depending bean names: bean name to Set of bean names for the bean's dependencies. */ private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;&gt;(64); //SingletonBeanRegistry接口的registerSingleton方法的实现 @Override public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException &#123; Assert.notNull(beanName, "Bean name must not be null"); Assert.notNull(singletonObject, "Singleton object must not be null"); synchronized (this.singletonObjects) &#123; Object oldObject = this.singletonObjects.get(beanName); // 该名称已被占用 if (oldObject != null) &#123; throw new IllegalStateException("Could not register object [" + singletonObject + "] under bean name '" + beanName + "': there is already object [" + oldObject + "] bound"); &#125; // 真正的注册操作在这里实现 addSingleton(beanName, singletonObject); &#125; &#125; /** * Add the given singleton object to the singleton cache of this factory. * &lt;p&gt;To be called for eager registration of singletons. * @param beanName the name of the bean * @param singletonObject the singleton object */ protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; this.singletonObjects.put(beanName, singletonObject); // beanName已被注册存放在singletonObjects缓存，那么singletonFactories不应该再持有名称为beanName的工厂 this.singletonFactories.remove(beanName); // beanName已被注册存放在singletonObjects缓存，那么earlySingletonObjects不应该再持有名称为beanName的bean。 this.earlySingletonObjects.remove(beanName); // beanName放进单例注册表中 this.registeredSingletons.add(beanName); &#125; &#125; /** * 添加 名称为beanName的singletonFactory对象 * * Add the given singleton factory for building the specified singleton * if necessary. * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to * resolve circular references. * @param beanName the name of the bean * @param singletonFactory the factory for the singleton object */ protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(singletonFactory, "Singleton factory must not be null"); synchronized (this.singletonObjects) &#123; if (!this.singletonObjects.containsKey(beanName)) &#123; // 判断singletonObjects内名字为beanName是否被占用，若没有，进行注册操作 this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125; &#125; //SingletonBeanRegistry接口的getSingleton方法的实现 @Override @Nullable public Object getSingleton(String beanName) &#123; return getSingleton(beanName, true); &#125; /** * Return the (raw) singleton object registered under the given name. * &lt;p&gt;Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or &#123;@code null&#125; if none found */ @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); // 如果是null，则判断是否正在创建 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); // 如果earlySingletonObjects指定的beanName的对象是不存在的且allowEarlyReference是允许的 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); // 如果存在指定beanName的singletonFactory对象 if (singletonFactory != null) &#123; // singletonFactory创建指定的单例对象 singletonObject = singletonFactory.getObject(); // 这里可以看出earlySingletonObjects缓存应该是存放singletonFactory产生的singleton this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject; &#125; /** * 返回在给定名称下注册的（原始）单例对象， * 如果尚未注册，则使用执行的工厂类创建并注册 * * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */ public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, "Bean name must not be null"); synchronized (this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; // 如果目前在销毁singellton if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, "Singleton bean creation not allowed while singletons of this factory are in destruction " + "(Do not request a bean from a BeanFactory in a destroy method implementation!)"); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Creating shared instance of singleton bean '" + beanName + "'"); &#125; // 单例对象创建前的回调 // singletonsCurrentlyInCreation中添加beanName beforeSingletonCreation(beanName); boolean newSingleton = false; // 判断存储异常相关原因的集合是否已存在 boolean recordSuppressedExceptions = (this.suppressedExceptions == null); // 若没有，刚创建异常集合的实例 if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;&gt;(); &#125; try &#123; // 由参数给定的singletonFactory创建singleton对象,getObject方法的具体由ObjectFactory的实现类决定 singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException ex) &#123; // Has the singleton object implicitly appeared in the meantime -&gt; // if yes, proceed with it since the exception indicates that state. //在此期间是否隐含地出现了单例对象,如果是，则继续执行，因为异常表示该状态。 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw ex; &#125; &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; // 结束前，将异常集合销毁掉 if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; // 单例创建之后的回调, //singletonsCurrentlyInCreation中移除beanName afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; // 注册创建后的单例 addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125; &#125; /** * 注册发生在singeton bean实例创建期间发生的异常 * * Register an Exception that happened to get suppressed during the creation of a * singleton bean instance, e.g. a temporary circular reference resolution problem. * @param ex the Exception to register */ protected void onSuppressedException(Exception ex) &#123; synchronized (this.singletonObjects) &#123; if (this.suppressedExceptions != null) &#123; this.suppressedExceptions.add(ex); &#125; &#125; &#125; /** * 移除名称为beanName的单例,主要在四个集合中移除， * * Remove the bean with the given name from the singleton cache of this factory, * to be able to clean up eager registration of a singleton if creation failed. * @param beanName the name of the bean * @see #getSingletonMutex() */ protected void removeSingleton(String beanName) &#123; synchronized (this.singletonObjects) &#123; this.singletonObjects.remove(beanName); this.singletonFactories.remove(beanName); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.remove(beanName); &#125; &#125; // SingletonBeanRegistry接口的containsSingleton方法实现 @Override public boolean containsSingleton(String beanName) &#123; return this.singletonObjects.containsKey(beanName); &#125; // SingletonBeanRegistry接口的getSingletonNames方法实现 @Override public String[] getSingletonNames() &#123; // 对singletonObjects加锁，可能是为了防止registeredSingletons和singletonObjects出现不一致的问题 synchronized (this.singletonObjects) &#123; return StringUtils.toStringArray(this.registeredSingletons); &#125; &#125; // SingletonBeanRegistry接口的getSingletonCount方法实现 @Override public int getSingletonCount() &#123; synchronized (this.singletonObjects) &#123; return this.registeredSingletons.size(); &#125; &#125; public void setCurrentlyInCreation(String beanName, boolean inCreation) &#123; Assert.notNull(beanName, "Bean name must not be null"); if (!inCreation) &#123; this.inCreationCheckExclusions.add(beanName); &#125; else &#123; this.inCreationCheckExclusions.remove(beanName); &#125; &#125; public boolean isCurrentlyInCreation(String beanName) &#123; Assert.notNull(beanName, "Bean name must not be null"); return (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; isActuallyInCreation(beanName)); &#125; protected boolean isActuallyInCreation(String beanName) &#123; return isSingletonCurrentlyInCreation(beanName); &#125; /** * 指定的bean是否正在被创建 * * Return whether the specified singleton bean is currently in creation * (within the entire factory). * @param beanName the name of the bean */ public boolean isSingletonCurrentlyInCreation(String beanName) &#123; return this.singletonsCurrentlyInCreation.contains(beanName); &#125; /** * Callback before singleton creation. * &lt;p&gt;The default implementation register the singleton as currently in creation. * @param beanName the name of the singleton about to be created * @see #isSingletonCurrentlyInCreation */ protected void beforeSingletonCreation(String beanName) &#123; if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; &#125; /** * Callback after singleton creation. * &lt;p&gt;The default implementation marks the singleton as not in creation anymore. * @param beanName the name of the singleton that has been created * @see #isSingletonCurrentlyInCreation */ protected void afterSingletonCreation(String beanName) &#123; if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.remove(beanName)) &#123; throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation"); &#125; &#125; /** * 一次性bean注册，存放在disponsableBeans集合中 * * Add the given bean to the list of disposable beans in this registry. * &lt;p&gt;Disposable beans usually correspond to registered singletons, * matching the bean name but potentially being a different instance * (for example, a DisposableBean adapter for a singleton that does not * naturally implement Spring's DisposableBean interface). * @param beanName the name of the bean * @param bean the bean instance */ public void registerDisposableBean(String beanName, DisposableBean bean) &#123; synchronized (this.disposableBeans) &#123; this.disposableBeans.put(beanName, bean); &#125; &#125; /** * 注册两个bean之间的包含关系,例如内部bean和包含其的外部bean之间 * * Register a containment relationship between two beans, * e.g. between an inner bean and its containing outer bean. * &lt;p&gt;Also registers the containing bean as dependent on the contained bean * in terms of destruction order. * @param containedBeanName the name of the contained (inner) bean * @param containingBeanName the name of the containing (outer) bean * @see #registerDependentBean */ public void registerContainedBean(String containedBeanName, String containingBeanName) &#123; synchronized (this.containedBeanMap) &#123; // 从containedBeanMap缓存中查找外部bean名为containingBeanName的内部bean集合 // 如果没有，刚新建一个存放内部bean的集合，并且存放在containedBeanMap缓存中 Set&lt;String&gt; containedBeans = this.containedBeanMap.computeIfAbsent(containingBeanName, k -&gt; new LinkedHashSet&lt;&gt;(8)); // 将名为containedBeanName的内部bean存放到内部bean集合 if (!containedBeans.add(containedBeanName)) &#123; return; &#125; &#125; // 紧接着调用注册内部bean和外部bean的依赖关系的方法 registerDependentBean(containedBeanName, containingBeanName); &#125; /** * 注册给定bean的一个依赖bean，给定的bean销毁之前被销毁。 * * Register a dependent bean for the given bean, * to be destroyed before the given bean is destroyed. * @param beanName the name of the bean * @param dependentBeanName the name of the dependent bean */ public void registerDependentBean(String beanName, String dependentBeanName) &#123; // 调用SimpleAliasRegistry的canonicalName方法，这方法是将参数beanName当做别名寻找到注册名，并依此递归 String canonicalName = canonicalName(beanName); synchronized (this.dependentBeanMap) &#123; // 从dependentBeanMap缓存中找到依赖名为canonicalName这个bean的 依赖bean集合 Set&lt;String&gt; dependentBeans = this.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; new LinkedHashSet&lt;&gt;(8)); // 依赖bean集合添加参数2指定的dependentBeanName if (!dependentBeans.add(dependentBeanName)) &#123; return; &#125; &#125; synchronized (this.dependenciesForBeanMap) &#123; // 从dependenciesForBeanMap缓存中找到 dependentBeanName 要依赖的所有bean集合 Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; new LinkedHashSet&lt;&gt;(8)); dependenciesForBean.add(canonicalName); &#125; &#125; /** * * beanName * * Determine whether the specified dependent bean has been registered as * dependent on the given bean or on any of its transitive dependencies. * @param beanName the name of the bean to check * @param dependentBeanName the name of the dependent bean * @since 4.0 */ protected boolean isDependent(String beanName, String dependentBeanName) &#123; synchronized (this.dependentBeanMap) &#123; return isDependent(beanName, dependentBeanName, null); &#125; &#125; // dependentBeanName是否依赖于 当前beanName private boolean isDependent(String beanName, String dependentBeanName, @Nullable Set&lt;String&gt; alreadySeen) &#123; if (alreadySeen != null &amp;&amp; alreadySeen.contains(beanName)) &#123; return false; &#125; String canonicalName = canonicalName(beanName); // 拿到依赖于当前的bean 的所有的beanName集合 Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName); if (dependentBeans == null) &#123; return false; &#125; // 依赖当前bean if (dependentBeans.contains(dependentBeanName)) &#123; return true; &#125; // 递归处理间接依赖 for (String transitiveDependency : dependentBeans) &#123; if (alreadySeen == null) &#123; alreadySeen = new HashSet&lt;&gt;(); &#125; alreadySeen.add(beanName); if (isDependent(transitiveDependency , dependentBeanName, alreadySeen)) &#123; return true; &#125; &#125; return false; &#125; /** * 确定是否还存在 名为beanName的 被依赖关系 * * Determine whether a dependent bean has been registered for the given name. * @param beanName the name of the bean to check */ protected boolean hasDependentBean(String beanName) &#123; return this.dependentBeanMap.containsKey(beanName); &#125; /** * 返回 依赖于指定的bean的所有bean的名称，如果有的话。 * * Return the names of all beans which depend on the specified bean, if any. * @param beanName the name of the bean * @return the array of dependent bean names, or an empty array if none */ public String[] getDependentBeans(String beanName) &#123; Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(beanName); if (dependentBeans == null) &#123; return new String[0]; &#125; synchronized (this.dependentBeanMap) &#123; return StringUtils.toStringArray(dependentBeans); &#125; &#125; /** * * 返回 指定的bean依赖的 所有的bean的名称，如果有的话。 * * Return the names of all beans that the specified bean depends on, if any. * @param beanName the name of the bean * @return the array of names of beans which the bean depends on, * or an empty array if none */ public String[] getDependenciesForBean(String beanName) &#123; Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(beanName); if (dependenciesForBean == null) &#123; return new String[0]; &#125; synchronized (this.dependenciesForBeanMap) &#123; return StringUtils.toStringArray(dependenciesForBean); &#125; &#125; /** * 销毁单例 */ public void destroySingletons() &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Destroying singletons in " + this); &#125; synchronized (this.singletonObjects) &#123; // 单例目前销毁标志开始 this.singletonsCurrentlyInDestruction = true; &#125; // 销毁disposableBeans缓存中所有单例bean String[] disposableBeanNames; synchronized (this.disposableBeans) &#123; disposableBeanNames = StringUtils.toStringArray(this.disposableBeans.keySet()); &#125; for (int i = disposableBeanNames.length - 1; i &gt;= 0; i--) &#123; destroySingleton(disposableBeanNames[i]); &#125; // containedBeanMap缓存清空 // dependentBeanMap缓存清空 // dependenciesForBeanMap缓存清空 this.containedBeanMap.clear(); this.dependentBeanMap.clear(); this.dependenciesForBeanMap.clear(); clearSingletonCache(); &#125; /** * Clear all cached singleton instances in this registry. * @since 4.3.15 */ protected void clearSingletonCache() &#123; synchronized (this.singletonObjects) &#123; //销毁四个map缓存 this.singletonObjects.clear(); this.singletonFactories.clear(); this.earlySingletonObjects.clear(); this.registeredSingletons.clear(); // 单例目前正在销毁标志为结束 this.singletonsCurrentlyInDestruction = false; &#125; &#125; /** * Destroy the given bean. Delegates to &#123;@code destroyBean&#125; * if a corresponding disposable bean instance is found. * @param beanName the name of the bean * @see #destroyBean */ public void destroySingleton(String beanName) &#123; // Remove a registered singleton of the given name, if any. removeSingleton(beanName); // 销毁相应的DisposableBean实例 // Destroy the corresponding DisposableBean instance. DisposableBean disposableBean; synchronized (this.disposableBeans) &#123; disposableBean = (DisposableBean) this.disposableBeans.remove(beanName); &#125; destroyBean(beanName, disposableBean); &#125; /** * 销毁给定的bean，在销毁之前，必须销毁所有依赖于给定的bean的bean * * Destroy the given bean. Must destroy beans that depend on the given * bean before the bean itself. Should not throw any exceptions. * @param beanName the name of the bean * @param bean the bean instance to destroy */ protected void destroyBean(String beanName, @Nullable DisposableBean bean) &#123; // 触发销毁所有 依赖当前bean 的bean们 // Trigger destruction of dependent beans first... Set&lt;String&gt; dependencies; synchronized (this.dependentBeanMap) &#123; // Within full synchronization in order to guarantee a disconnected Set dependencies = this.dependentBeanMap.remove(beanName); &#125; if (dependencies != null) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Retrieved dependent beans for bean '" + beanName + "': " + dependencies); &#125; for (String dependentBeanName : dependencies) &#123; // 遍历销毁 destroySingleton(dependentBeanName); &#125; &#125; // 销毁当前的bean // Actually destroy the bean now... if (bean != null) &#123; try &#123; bean.destroy(); &#125; catch (Throwable ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Destruction of bean with name '" + beanName + "' threw an exception", ex); &#125; &#125; &#125; // 触发销毁 包含的beans // Trigger destruction of contained beans... Set&lt;String&gt; containedBeans; synchronized (this.containedBeanMap) &#123; // Within full synchronization in order to guarantee a disconnected Set containedBeans = this.containedBeanMap.remove(beanName); &#125; if (containedBeans != null) &#123; for (String containedBeanName : containedBeans) &#123; destroySingleton(containedBeanName); &#125; &#125; // Remove destroyed bean from other beans' dependencies. // 移除当前 Bean所依赖的Bean的集合， synchronized (this.dependentBeanMap) &#123; for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = this.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123; Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next(); Set&lt;String&gt; dependenciesToClean = entry.getValue(); dependenciesToClean.remove(beanName); if (dependenciesToClean.isEmpty()) &#123; it.remove(); &#125; &#125; &#125; // 最后 从dependenciesForBeanMap缓存中移除要销毁的bean // Remove destroyed bean's prepared dependency information. this.dependenciesForBeanMap.remove(beanName); &#125; public final Object getSingletonMutex() &#123; return this.singletonObjects; &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析2-BeanDefinition]]></title>
    <url>%2F2019%2F08%2F31%2FSpring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-BeanDefinition%2F</url>
    <content type="text"><![CDATA[BeanDefinition描述了一个bean实例，是配置文件\&lt;bean>元素标签在容器中内部表示形式。 它具有属性值，构造函数参数值以及具体实现提供的更多信息。这是一个最小化的接口，主要的意向是允许一个BeanFactoryPostProcessor来修改它的属性值和其他的元数据。 1 继承关系BeanDefinition继承了AttributeAccessor，说明它具有处理属性的能力 BeanDefinition继承了BeanMetadataElement，说明它可以持有Bean元数据元素，作用是可以持有XML文件的一个bean标签对应的Object。 继承关系： 1.1 BeanMetadataElement接口1234567891011121314/** * 由携带配置源对象的bean元数据元素实现的接口。 */public interface BeanMetadataElement &#123; /** * 返回此元数据元素的配置源 */ @Nullable default Object getSource() &#123; return null; &#125;&#125; 1.1.1 BeanMetadataAttribute类BeanMetadataAttribute类是BeanMetadataElement接口的一个实现。通常作为BeanDefinition的一部分。 以key-value的形式持有属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class BeanMetadataAttribute implements BeanMetadataElement &#123; // 键值对中的key private final String name; // 键值对中的value @Nullable private final Object value; @Nullable private Object source; /** * Create a new AttributeValue instance. * @param name the name of the attribute (never &#123;@code null&#125;) * @param value the value of the attribute (possibly before type conversion) */ public BeanMetadataAttribute(String name, @Nullable Object value) &#123; Assert.notNull(name, "Name must not be null"); this.name = name; this.value = value; &#125; /** * Return the name of the attribute. */ public String getName() &#123; return this.name; &#125; /** * Return the value of the attribute. */ @Nullable public Object getValue() &#123; return this.value; &#125; /** * Set the configuration source &#123;@code Object&#125; for this metadata element. * &lt;p&gt;The exact type of the object will depend on the configuration mechanism used. */ public void setSource(@Nullable Object source) &#123; this.source = source; &#125; @Override @Nullable public Object getSource() &#123; return this.source; &#125; @Override public boolean equals(@Nullable Object other) &#123; if (this == other) &#123; return true; &#125; if (!(other instanceof BeanMetadataAttribute)) &#123; return false; &#125; BeanMetadataAttribute otherMa = (BeanMetadataAttribute) other; return (this.name.equals(otherMa.name) &amp;&amp; ObjectUtils.nullSafeEquals(this.value, otherMa.value) &amp;&amp; ObjectUtils.nullSafeEquals(this.source, otherMa.source)); &#125; @Override public int hashCode() &#123; return this.name.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.value); &#125; @Override public String toString() &#123; return "metadata attribute '" + this.name + "'"; &#125;&#125; 1.2 AttributeAccessor接口12345678910111213141516171819202122232425262728293031323334/** * 定义用于向/从任意对象附加和访问元数据的通用契约的接口。 */public interface AttributeAccessor &#123; /** * 将属性名设置为给定的值value。如果value是null，这个属性会被移除 * 为防止属性名重叠，最好用类或者包名作为前缀。 */ void setAttribute(String name, @Nullable Object value); /** * 根据属性名获取属性值 */ @Nullable Object getAttribute(String name); /** * 移除属性名，并返回它的值 */ @Nullable Object removeAttribute(String name); /** * 属性是否存在 */ boolean hasAttribute(String name); /** * 返回所有的属性名数组 */ String[] attributeNames();&#125; 1.2.1 AttributeAccessorSupport虚类Abstract AttributeAccessorSupport类是AccessorSupport的一个实现。实现了AccessorSupport接口的中的方法。 这个类很简单，就是使用了一个map来存储属性，key为String，value为任意对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable &#123; //使用一个map来存储属性值。 /** Map with String keys and Object values. */ private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;(); @Override public void setAttribute(String name, @Nullable Object value) &#123; Assert.notNull(name, "Name must not be null"); if (value != null) &#123; this.attributes.put(name, value); &#125; else &#123; removeAttribute(name); &#125; &#125; @Override @Nullable public Object getAttribute(String name) &#123; Assert.notNull(name, "Name must not be null"); return this.attributes.get(name); &#125; @Override @Nullable public Object removeAttribute(String name) &#123; Assert.notNull(name, "Name must not be null"); return this.attributes.remove(name); &#125; @Override public boolean hasAttribute(String name) &#123; Assert.notNull(name, "Name must not be null"); return this.attributes.containsKey(name); &#125; @Override public String[] attributeNames() &#123; return StringUtils.toStringArray(this.attributes.keySet()); &#125; /** * Copy the attributes from the supplied AttributeAccessor to this accessor. * @param source the AttributeAccessor to copy from */ protected void copyAttributesFrom(AttributeAccessor source) &#123; Assert.notNull(source, "Source must not be null"); String[] attributeNames = source.attributeNames(); for (String attributeName : attributeNames) &#123; setAttribute(attributeName, source.getAttribute(attributeName)); &#125; &#125; @Override public boolean equals(@Nullable Object other) &#123; return (this == other || (other instanceof AttributeAccessorSupport &amp;&amp; this.attributes.equals(((AttributeAccessorSupport) other).attributes))); &#125; @Override public int hashCode() &#123; return this.attributes.hashCode(); &#125;&#125; 1.2.2 BeanMetadataAttributeAccessor类BeanMetadataAttributeAccessor是AttributeAccessorSupport的一个子类，并且实现了BeanMetadataElement接口。 以BeanMetadataAttribute对象的形式来持有属性，以便跟踪 定义源。 BeanMetadataAttribute中以key-value的形式持有了一个属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BeanMetadataAttributeAccessor extends AttributeAccessorSupport implements BeanMetadataElement &#123; @Nullable private Object source; /** * Set the configuration source &#123;@code Object&#125; for this metadata element. * &lt;p&gt;The exact type of the object will depend on the configuration mechanism used. */ public void setSource(@Nullable Object source) &#123; this.source = source; &#125; @Override @Nullable public Object getSource() &#123; return this.source; &#125; /** * Add the given BeanMetadataAttribute to this accessor's set of attributes. * @param attribute the BeanMetadataAttribute object to register */ public void addMetadataAttribute(BeanMetadataAttribute attribute) &#123; //父类AttributeAccessorSupport 来处理，存储到父类AttributeAccessorSupport的map中 super.setAttribute(attribute.getName(), attribute); &#125; /** * Look up the given BeanMetadataAttribute in this accessor's set of attributes. * @param name the name of the attribute * @return the corresponding BeanMetadataAttribute object, * or &#123;@code null&#125; if no such attribute defined */ @Nullable public BeanMetadataAttribute getMetadataAttribute(String name) &#123; return (BeanMetadataAttribute) super.getAttribute(name); &#125; @Override public void setAttribute(String name, @Nullable Object value) &#123; super.setAttribute(name, new BeanMetadataAttribute(name, value)); &#125; @Override @Nullable public Object getAttribute(String name) &#123; BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.getAttribute(name); return (attribute != null ? attribute.getValue() : null); &#125; @Override @Nullable public Object removeAttribute(String name) &#123; BeanMetadataAttribute attribute = (BeanMetadataAttribute) super.removeAttribute(name); return (attribute != null ? attribute.getValue() : null); &#125;&#125; 2 BeanDefinition分析将Bean的定义信息存储到这个BeanDefinition相应的属性中，后面对Bean的操作就直接对BeanDefinition进行，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。 下面看BeanDefinition源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243/** * BeanDefinition描述了一个bean实例，它具有属性值、构造函数参数值、以及更多这个接口的具体实现类提供的更多信息 * * 这是一个最小化的接口，主要的意向是允许一个BeanFactoryPostProcessor来修改它的属性值和其他的元数据。 */public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123; /** * 单例 */ String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; /** * 原型 */ String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; /** * 角色提示指示 * 通常对应一个用户自定义的bean */ int ROLE_APPLICATION = 0; /** * 角色提示指示 */ int ROLE_SUPPORT = 1; /** * 角色提示指示 * * 完全是后台角色，与终端用户无关 * 内部工作使用 */ int ROLE_INFRASTRUCTURE = 2; // Modifiable attributes /** * 设置当前bean definition的父bean definition */ void setParentName(@Nullable String parentName); /** * 返回父bean definition */ @Nullable String getParentName(); /** * 指定当前bean definition的类名 * 在 bean工厂后处理 期间可以修改类名，通常用解析后的变体替换原始类名。 */ void setBeanClassName(@Nullable String beanClassName); /** * 返回此bean定义的当前bean类名 */ @Nullable String getBeanClassName(); /** * 设置范围 * @see #SCOPE_SINGLETON * @see #SCOPE_PROTOTYPE */ void setScope(@Nullable String scope); @Nullable String getScope(); /** * 设置是否延迟初始化。 */ void setLazyInit(boolean lazyInit); boolean isLazyInit(); /** * * 设置此bean依赖于初始化的bean的名称 * bean工厂将保证首先初始化这些bean。 */ void setDependsOn(@Nullable String... dependsOn); /** * Return the bean names that this bean depends on. */ @Nullable String[] getDependsOn(); /** * 设置此bean是否可以自动注入到其他bean中 * 只会影响 按类自动注入，不影响按名自动注入 */ void setAutowireCandidate(boolean autowireCandidate); /** * Return whether this bean is a candidate for getting autowired into some other bean. */ boolean isAutowireCandidate(); /** * 设置此bean是否为主要autowire候选者。 */ void setPrimary(boolean primary); boolean isPrimary(); /** * 指定factory bean */ void setFactoryBeanName(@Nullable String factoryBeanName); /** * 返回当前bean的factory bean */ @Nullable String getFactoryBeanName(); /** * 指定工厂方法 */ void setFactoryMethodName(@Nullable String factoryMethodName); /** * Return a factory method, if any. */ @Nullable String getFactoryMethodName(); /** * 返回构造器参数对象 */ ConstructorArgumentValues getConstructorArgumentValues(); /** * 返回 是否构造器参数 已经定义了 */ default boolean hasConstructorArgumentValues() &#123; return !getConstructorArgumentValues().isEmpty(); &#125; /** * * 返回属性对象 */ MutablePropertyValues getPropertyValues(); /** * 返回是否为此bean定义了属性值 */ default boolean hasPropertyValues() &#123; return !getPropertyValues().isEmpty(); &#125; /** * 设置初始化方法的名称。 */ void setInitMethodName(@Nullable String initMethodName); @Nullable String getInitMethodName(); /** * 设置destroy方法 */ void setDestroyMethodName(@Nullable String destroyMethodName); /** * 返回destroy方法 */ @Nullable String getDestroyMethodName(); /** * 设置角色提示 * @see #ROLE_APPLICATION * @see #ROLE_SUPPORT * @see #ROLE_INFRASTRUCTURE */ void setRole(int role); /** * @see #ROLE_APPLICATION * @see #ROLE_SUPPORT * @see #ROLE_INFRASTRUCTURE */ int getRole(); /** * 设置一个人类易读的描述 * Set a human-readable description of this bean definition. * @since 5.1 */ void setDescription(@Nullable String description); /** * 返回描述 * Return a human-readable description of this bean definition. */ @Nullable String getDescription(); // Read-only attributes /** * 返回当前beanDefinition的一个ResolvableType * 见Spring源码分析5-ResolvableType */ ResolvableType getResolvableType(); /** * 返回是否是一个单例bean */ boolean isSingleton(); /** * 返回是否是一个原型bean */ boolean isPrototype(); /** * 返回当前bean是否是abstract，如果是，则不会被实例化 */ boolean isAbstract(); /** * 返回此bean定义的资源的描述 */ @Nullable String getResourceDescription(); /** * 返回原始BeanDefinition */ @Nullable BeanDefinition getOriginatingBeanDefinition();&#125; 可以看到上面的很多属性和方法都很熟悉，例如类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等 3 ConstructorArgumentValues类持有构造器的参数值，通常是一个BeanDefiniton的一部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619public class ConstructorArgumentValues &#123; //Integer为参数在构造器中的顺序值 private final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues = new LinkedHashMap&lt;&gt;(); private final List&lt;ValueHolder&gt; genericArgumentValues = new ArrayList&lt;&gt;(); /** * Create a new empty ConstructorArgumentValues object. */ public ConstructorArgumentValues() &#123; &#125; /** * 深拷贝 * Deep copy constructor. * @param original the ConstructorArgumentValues to copy */ public ConstructorArgumentValues(ConstructorArgumentValues original) &#123; addArgumentValues(original); &#125; /** * Copy all given argument values into this object, using separate holder * instances to keep the values independent from the original object. * &lt;p&gt;Note: Identical ValueHolder instances will only be registered once, * to allow for merging and re-merging of argument value definitions. Distinct * ValueHolder instances carrying the same content are of course allowed. */ public void addArgumentValues(@Nullable ConstructorArgumentValues other) &#123; if (other != null) &#123; other.indexedArgumentValues.forEach( (index, argValue) -&gt; addOrMergeIndexedArgumentValue(index, argValue.copy()) ); other.genericArgumentValues.stream() .filter(valueHolder -&gt; !this.genericArgumentValues.contains(valueHolder)) .forEach(valueHolder -&gt; addOrMergeGenericArgumentValue(valueHolder.copy())); &#125; &#125; /** * 在构造函数参数列表中为给定索引添加参数值。 * * Add an argument value for the given index in the constructor argument list. * @param index the index in the constructor argument list * @param value the argument value */ public void addIndexedArgumentValue(int index, @Nullable Object value) &#123; addIndexedArgumentValue(index, new ValueHolder(value)); &#125; /** * 在构造函数参数列表中为给定索引添加参数值。 * Add an argument value for the given index in the constructor argument list. * @param index the index in the constructor argument list * @param value the argument value * @param type the type of the constructor argument */ public void addIndexedArgumentValue(int index, @Nullable Object value, String type) &#123; addIndexedArgumentValue(index, new ValueHolder(value, type)); &#125; /** * 在构造函数参数列表中为给定索引添加参数值。 * Add an argument value for the given index in the constructor argument list. * @param index the index in the constructor argument list * @param newValue the argument value in the form of a ValueHolder */ public void addIndexedArgumentValue(int index, ValueHolder newValue) &#123; Assert.isTrue(index &gt;= 0, "Index must not be negative"); Assert.notNull(newValue, "ValueHolder must not be null"); addOrMergeIndexedArgumentValue(index, newValue); &#125; /** * 在构造函数参数列表中为给定索引添加参数值，将新值（通常是集合）与当前值合并 * * Add an argument value for the given index in the constructor argument list, * merging the new value (typically a collection) with the current value * if demanded: see &#123;@link org.springframework.beans.Mergeable&#125;. * @param key the index in the constructor argument list * @param newValue the argument value in the form of a ValueHolder */ private void addOrMergeIndexedArgumentValue(Integer key, ValueHolder newValue) &#123; ValueHolder currentValue = this.indexedArgumentValues.get(key); if (currentValue != null &amp;&amp; newValue.getValue() instanceof Mergeable) &#123; Mergeable mergeable = (Mergeable) newValue.getValue(); if (mergeable.isMergeEnabled()) &#123; newValue.setValue(mergeable.merge(currentValue.getValue())); &#125; &#125; this.indexedArgumentValues.put(key, newValue); &#125; /** * 检查是否已为给定索引注册参数值。 * * Check whether an argument value has been registered for the given index. * @param index the index in the constructor argument list */ public boolean hasIndexedArgumentValue(int index) &#123; return this.indexedArgumentValues.containsKey(index); &#125; /** * 获取构造函数参数列表中给定索引的参数值。 * * Get argument value for the given index in the constructor argument list. * @param index the index in the constructor argument list * @param requiredType the type to match (can be &#123;@code null&#125; to match * untyped values only) * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getIndexedArgumentValue(int index, @Nullable Class&lt;?&gt; requiredType) &#123; return getIndexedArgumentValue(index, requiredType, null); &#125; /** * 获取构造函数参数列表中给定索引的参数值。 * * Get argument value for the given index in the constructor argument list. * @param index the index in the constructor argument list * @param requiredType the type to match (can be &#123;@code null&#125; to match * untyped values only) * @param requiredName the type to match (can be &#123;@code null&#125; to match * unnamed values only, or empty String to match any name) * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getIndexedArgumentValue(int index, @Nullable Class&lt;?&gt; requiredType, @Nullable String requiredName) &#123; Assert.isTrue(index &gt;= 0, "Index must not be negative"); ValueHolder valueHolder = this.indexedArgumentValues.get(index); if (valueHolder != null &amp;&amp; (valueHolder.getType() == null || (requiredType != null &amp;&amp; ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) &amp;&amp; (valueHolder.getName() == null || "".equals(requiredName) || (requiredName != null &amp;&amp; requiredName.equals(valueHolder.getName())))) &#123; return valueHolder; &#125; return null; &#125; /** * 返回索引参数值的映射（只读的） * * Return the map of indexed argument values. * @return unmodifiable Map with Integer index as key and ValueHolder as value * @see ValueHolder */ public Map&lt;Integer, ValueHolder&gt; getIndexedArgumentValues() &#123; return Collections.unmodifiableMap(this.indexedArgumentValues); &#125; /** * 添加要按类型匹配的通用参数值。 * * Add a generic argument value to be matched by type. * &lt;p&gt;Note: A single generic argument value will just be used once, * rather than matched multiple times. * @param value the argument value */ public void addGenericArgumentValue(Object value) &#123; this.genericArgumentValues.add(new ValueHolder(value)); &#125; /** * 添加要按类型匹配的通用参数值。 * * Add a generic argument value to be matched by type. * &lt;p&gt;Note: A single generic argument value will just be used once, * rather than matched multiple times. * @param value the argument value * @param type the type of the constructor argument */ public void addGenericArgumentValue(Object value, String type) &#123; this.genericArgumentValues.add(new ValueHolder(value, type)); &#125; /** * 添加要通过类型或名称匹配的通用参数值（如果可用）。 * * Add a generic argument value to be matched by type or name (if available). * &lt;p&gt;Note: A single generic argument value will just be used once, * rather than matched multiple times. * @param newValue the argument value in the form of a ValueHolder * &lt;p&gt;Note: Identical ValueHolder instances will only be registered once, * to allow for merging and re-merging of argument value definitions. Distinct * ValueHolder instances carrying the same content are of course allowed. */ public void addGenericArgumentValue(ValueHolder newValue) &#123; Assert.notNull(newValue, "ValueHolder must not be null"); if (!this.genericArgumentValues.contains(newValue)) &#123; addOrMergeGenericArgumentValue(newValue); &#125; &#125; /** * 添加通用参数值，将新值（通常是集合）与当前值合并（如果需要） * * Add a generic argument value, merging the new value (typically a collection) * with the current value if demanded: see &#123;@link org.springframework.beans.Mergeable&#125;. * @param newValue the argument value in the form of a ValueHolder */ private void addOrMergeGenericArgumentValue(ValueHolder newValue) &#123; if (newValue.getName() != null) &#123; for (Iterator&lt;ValueHolder&gt; it = this.genericArgumentValues.iterator(); it.hasNext();) &#123; //遍历所有通用参数 ValueHolder currentValue = it.next(); if (newValue.getName().equals(currentValue.getName())) &#123; if (newValue.getValue() instanceof Mergeable) &#123; Mergeable mergeable = (Mergeable) newValue.getValue(); if (mergeable.isMergeEnabled()) &#123; newValue.setValue(mergeable.merge(currentValue.getValue())); &#125; &#125; it.remove(); &#125; &#125; &#125; this.genericArgumentValues.add(newValue); &#125; /** * 查找与给定类型匹配的泛型参数值。 * * Look for a generic argument value that matches the given type. * @param requiredType the type to match * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getGenericArgumentValue(Class&lt;?&gt; requiredType) &#123; return getGenericArgumentValue(requiredType, null, null); &#125; /** * Look for a generic argument value that matches the given type. * @param requiredType the type to match * @param requiredName the name to match * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getGenericArgumentValue(Class&lt;?&gt; requiredType, String requiredName) &#123; return getGenericArgumentValue(requiredType, requiredName, null); &#125; /** * 查找与给定类型匹配的下一个 泛型参数值，忽略已在当前解析过程中使用的参数值。 * * Look for the next generic argument value that matches the given type, * ignoring argument values that have already been used in the current * resolution process. * @param requiredType the type to match (can be &#123;@code null&#125; to find * an arbitrary next generic argument value) * @param requiredName the name to match (can be &#123;@code null&#125; to not * match argument values by name, or empty String to match any name) * @param usedValueHolders a Set of ValueHolder objects that have already been used * in the current resolution process and should therefore not be returned again * @return the ValueHolder for the argument, or &#123;@code null&#125; if none found */ @Nullable public ValueHolder getGenericArgumentValue(@Nullable Class&lt;?&gt; requiredType, @Nullable String requiredName, @Nullable Set&lt;ValueHolder&gt; usedValueHolders) &#123; for (ValueHolder valueHolder : this.genericArgumentValues) &#123; // 忽略已在当前解析过程中使用的参数值 if (usedValueHolders != null &amp;&amp; usedValueHolders.contains(valueHolder)) &#123; continue; &#125; //参数名字相同 忽略 if (valueHolder.getName() != null &amp;&amp; !"".equals(requiredName) &amp;&amp; (requiredName == null || !valueHolder.getName().equals(requiredName))) &#123; continue; &#125; // 类型不匹配，忽略 if (valueHolder.getType() != null &amp;&amp; (requiredType == null || !ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) &#123; continue; &#125; // 需要的值不能 分配 给指定的requiredType if (requiredType != null &amp;&amp; valueHolder.getType() == null &amp;&amp; valueHolder.getName() == null &amp;&amp; !ClassUtils.isAssignableValue(requiredType, valueHolder.getValue())) &#123; continue; &#125; //返回找到的参数值持有者对象 return valueHolder; &#125; return null; &#125; /** * 返回只读的通用参数值持有者List集合 * * Return the list of generic argument values. * @return unmodifiable List of ValueHolders * @see ValueHolder */ public List&lt;ValueHolder&gt; getGenericArgumentValues() &#123; return Collections.unmodifiableList(this.genericArgumentValues); &#125; /** * 根据索引和类别获取 值持有者对象 * * Look for an argument value that either corresponds to the given index * in the constructor argument list or generically matches by type. * @param index the index in the constructor argument list * @param requiredType the parameter type to match * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getArgumentValue(int index, Class&lt;?&gt; requiredType) &#123; return getArgumentValue(index, requiredType, null, null); &#125; /** * 根据索引、类别和参数名获取 值持有者对象 * * Look for an argument value that either corresponds to the given index * in the constructor argument list or generically matches by type. * @param index the index in the constructor argument list * @param requiredType the parameter type to match * @param requiredName the parameter name to match * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getArgumentValue(int index, Class&lt;?&gt; requiredType, String requiredName) &#123; return getArgumentValue(index, requiredType, requiredName, null); &#125; /** * Look for an argument value that either corresponds to the given index * in the constructor argument list or generically matches by type. * @param index the index in the constructor argument list * @param requiredType the parameter type to match (can be &#123;@code null&#125; * to find an untyped argument value) * @param requiredName the parameter name to match (can be &#123;@code null&#125; * to find an unnamed argument value, or empty String to match any name) * @param usedValueHolders a Set of ValueHolder objects that have already * been used in the current resolution process and should therefore not * be returned again (allowing to return the next generic argument match * in case of multiple generic argument values of the same type) * @return the ValueHolder for the argument, or &#123;@code null&#125; if none set */ @Nullable public ValueHolder getArgumentValue(int index, @Nullable Class&lt;?&gt; requiredType, @Nullable String requiredName, @Nullable Set&lt;ValueHolder&gt; usedValueHolders) &#123; Assert.isTrue(index &gt;= 0, "Index must not be negative"); //分别从indexedArgumentValues 和 genericArgumentValues中寻找 ValueHolder valueHolder = getIndexedArgumentValue(index, requiredType, requiredName); if (valueHolder == null) &#123; valueHolder = getGenericArgumentValue(requiredType, requiredName, usedValueHolders); &#125; return valueHolder; &#125; /** * Return the number of argument values held in this instance, * counting both indexed and generic argument values. */ public int getArgumentCount() &#123; return (this.indexedArgumentValues.size() + this.genericArgumentValues.size()); &#125; /** * Return if this holder does not contain any argument values, * neither indexed ones nor generic ones. */ public boolean isEmpty() &#123; return (this.indexedArgumentValues.isEmpty() &amp;&amp; this.genericArgumentValues.isEmpty()); &#125; /** * 清空 * Clear this holder, removing all argument values. */ public void clear() &#123; this.indexedArgumentValues.clear(); this.genericArgumentValues.clear(); &#125; @Override public boolean equals(@Nullable Object other) &#123; if (this == other) &#123; return true; &#125; if (!(other instanceof ConstructorArgumentValues)) &#123; return false; &#125; ConstructorArgumentValues that = (ConstructorArgumentValues) other; if (this.genericArgumentValues.size() != that.genericArgumentValues.size() || this.indexedArgumentValues.size() != that.indexedArgumentValues.size()) &#123; return false; &#125; Iterator&lt;ValueHolder&gt; it1 = this.genericArgumentValues.iterator(); Iterator&lt;ValueHolder&gt; it2 = that.genericArgumentValues.iterator(); while (it1.hasNext() &amp;&amp; it2.hasNext()) &#123; ValueHolder vh1 = it1.next(); ValueHolder vh2 = it2.next(); if (!vh1.contentEquals(vh2)) &#123; return false; &#125; &#125; for (Map.Entry&lt;Integer, ValueHolder&gt; entry : this.indexedArgumentValues.entrySet()) &#123; ValueHolder vh1 = entry.getValue(); ValueHolder vh2 = that.indexedArgumentValues.get(entry.getKey()); if (!vh1.contentEquals(vh2)) &#123; return false; &#125; &#125; return true; &#125; @Override public int hashCode() &#123; int hashCode = 7; for (ValueHolder valueHolder : this.genericArgumentValues) &#123; hashCode = 31 * hashCode + valueHolder.contentHashCode(); &#125; hashCode = 29 * hashCode; for (Map.Entry&lt;Integer, ValueHolder&gt; entry : this.indexedArgumentValues.entrySet()) &#123; hashCode = 31 * hashCode + (entry.getValue().contentHashCode() ^ entry.getKey().hashCode()); &#125; return hashCode; &#125; /** * 内部类，持有一个构造器参数的值 * 使用可选的type属性指示实际构造函数参数的目标类型 * * Holder for a constructor argument value, with an optional type * attribute indicating the target type of the actual constructor argument. */ public static class ValueHolder implements BeanMetadataElement &#123; @Nullable private Object value; @Nullable private String type; @Nullable private String name; @Nullable private Object source; // 转换标志 private boolean converted = false; @Nullable private Object convertedValue; /** * 构造函数 * Create a new ValueHolder for the given value. * @param value the argument value */ public ValueHolder(@Nullable Object value) &#123; this.value = value; &#125; /** * 构造函数 * Create a new ValueHolder for the given value and type. * @param value the argument value * @param type the type of the constructor argument */ public ValueHolder(@Nullable Object value, @Nullable String type) &#123; this.value = value; this.type = type; &#125; /** * 构造函数 * Create a new ValueHolder for the given value, type and name. * @param value the argument value * @param type the type of the constructor argument * @param name the name of the constructor argument */ public ValueHolder(@Nullable Object value, @Nullable String type, @Nullable String name) &#123; this.value = value; this.type = type; this.name = name; &#125; /** * Set the value for the constructor argument. */ public void setValue(@Nullable Object value) &#123; this.value = value; &#125; /** * Return the value for the constructor argument. */ @Nullable public Object getValue() &#123; return this.value; &#125; /** * Set the type of the constructor argument. */ public void setType(@Nullable String type) &#123; this.type = type; &#125; /** * Return the type of the constructor argument. */ @Nullable public String getType() &#123; return this.type; &#125; /** * Set the name of the constructor argument. */ public void setName(@Nullable String name) &#123; this.name = name; &#125; /** * Return the name of the constructor argument. */ @Nullable public String getName() &#123; return this.name; &#125; /** * Set the configuration source &#123;@code Object&#125; for this metadata element. * &lt;p&gt;The exact type of the object will depend on the configuration mechanism used. */ public void setSource(@Nullable Object source) &#123; this.source = source; &#125; @Override @Nullable public Object getSource() &#123; return this.source; &#125; /** * Return whether this holder contains a converted value already (&#123;@code true&#125;), * or whether the value still needs to be converted (&#123;@code false&#125;). */ public synchronized boolean isConverted() &#123; return this.converted; &#125; /** * Set the converted value of the constructor argument, * after processed type conversion. */ public synchronized void setConvertedValue(@Nullable Object value) &#123; this.converted = (value != null); this.convertedValue = value; &#125; /** * Return the converted value of the constructor argument, * after processed type conversion. */ @Nullable public synchronized Object getConvertedValue() &#123; return this.convertedValue; &#125; /** * 是否相等 * Determine whether the content of this ValueHolder is equal * to the content of the given other ValueHolder. * &lt;p&gt;Note that ValueHolder does not implement &#123;@code equals&#125; * directly, to allow for multiple ValueHolder instances with the * same content to reside in the same Set. */ private boolean contentEquals(ValueHolder other) &#123; return (this == other || (ObjectUtils.nullSafeEquals(this.value, other.value) &amp;&amp; ObjectUtils.nullSafeEquals(this.type, other.type))); &#125; /** * 确定此ValueHolder的内容的哈希码。 * * Determine whether the hash code of the content of this ValueHolder. * &lt;p&gt;Note that ValueHolder does not implement &#123;@code hashCode&#125; * directly, to allow for multiple ValueHolder instances with the * same content to reside in the same Set. */ private int contentHashCode() &#123; return ObjectUtils.nullSafeHashCode(this.value) * 29 + ObjectUtils.nullSafeHashCode(this.type); &#125; /** * Create a copy of this ValueHolder: that is, an independent * ValueHolder instance with the same contents. */ public ValueHolder copy() &#123; ValueHolder copy = new ValueHolder(this.value, this.type, this.name); copy.setSource(this.source); return copy; &#125; &#125;&#125; 4 MutablePropertyValues类MutablePropertyValues类实现了PropertyValues接口。 MutablePropertyValues是PropertyValues接口的默认实现，允许对属性进行简单操作，并提供构造函数以支持Map中的深层复制和构造。 4.1 PropertyValue类PropertyValue用于保存单个bean属性的信息和值的对象。使用PropertyValue对象，而不是仅将所有属性存储在键为属性名的mao中，可以更灵活，并且能够以更优化的方式处理索引属性等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** * 用于保存单个bean属性的信息和值的对象 * 使用PropertyValue对象，而不是仅将所有属性存储在键为属性名的mao中，可以更灵活，并且能够以更优化的方式处理索引属性等。 * * Object to hold information and value for an individual bean property. * Using an object here, rather than just storing all properties in * a map keyed by property name, allows for more flexibility（灵活性）, and the * ability to handle indexed properties etc in an optimized（优化） way. * * &lt;p&gt;Note that the value doesn't need to be the final required type: * A &#123;@link BeanWrapper&#125; implementation should handle any necessary conversion, * as this object doesn't know anything about the objects it will be applied to. * * @author Rod Johnson * @author Rob Harrop * @author Juergen Hoeller * @since 13 May 2001 * @see PropertyValues * @see BeanWrapper */@SuppressWarnings("serial")public class PropertyValue extends BeanMetadataAttributeAccessor implements Serializable &#123; private final String name; @Nullable private final Object value; private boolean optional = false; private boolean converted = false; @Nullable private Object convertedValue; /** Package-visible field that indicates whether conversion is necessary. */ @Nullable volatile Boolean conversionNecessary; /** Package-visible field for caching the resolved property path tokens. */ @Nullable transient volatile Object resolvedTokens; /** * Create a new PropertyValue instance. * @param name the name of the property (never &#123;@code null&#125;) * @param value the value of the property (possibly before type conversion) */ public PropertyValue(String name, @Nullable Object value) &#123; Assert.notNull(name, "Name must not be null"); this.name = name; this.value = value; &#125; /** * Copy constructor. * @param original the PropertyValue to copy (never &#123;@code null&#125;) */ public PropertyValue(PropertyValue original) &#123; Assert.notNull(original, "Original must not be null"); this.name = original.getName(); this.value = original.getValue(); this.optional = original.isOptional(); this.converted = original.converted; this.convertedValue = original.convertedValue; this.conversionNecessary = original.conversionNecessary; this.resolvedTokens = original.resolvedTokens; setSource(original.getSource()); copyAttributesFrom(original); &#125; /** * Constructor that exposes a new value for an original value holder. * The original holder will be exposed as source of the new holder. * @param original the PropertyValue to link to (never &#123;@code null&#125;) * @param newValue the new value to apply */ public PropertyValue(PropertyValue original, @Nullable Object newValue) &#123; Assert.notNull(original, "Original must not be null"); this.name = original.getName(); this.value = newValue; this.optional = original.isOptional(); this.conversionNecessary = original.conversionNecessary; this.resolvedTokens = original.resolvedTokens; setSource(original); copyAttributesFrom(original); &#125; /** * Return the name of the property. */ public String getName() &#123; return this.name; &#125; /** * Return the value of the property. * &lt;p&gt;Note that type conversion will &lt;i&gt;not&lt;/i&gt; have occurred here. * It is the responsibility of the BeanWrapper implementation to * perform type conversion. */ @Nullable public Object getValue() &#123; return this.value; &#125; /** * Return the original PropertyValue instance for this value holder. * @return the original PropertyValue (either a source of this * value holder or this value holder itself). */ public PropertyValue getOriginalPropertyValue() &#123; PropertyValue original = this; Object source = getSource(); while (source instanceof PropertyValue &amp;&amp; source != original) &#123; original = (PropertyValue) source; source = original.getSource(); &#125; return original; &#125; /** * Set whether this is an optional value, that is, to be ignored * when no corresponding property exists on the target class. * @since 3.0 */ public void setOptional(boolean optional) &#123; this.optional = optional; &#125; /** * Return whether this is an optional value, that is, to be ignored * when no corresponding property exists on the target class. * @since 3.0 */ public boolean isOptional() &#123; return this.optional; &#125; /** * Return whether this holder contains a converted value already (&#123;@code true&#125;), * or whether the value still needs to be converted (&#123;@code false&#125;). */ public synchronized boolean isConverted() &#123; return this.converted; &#125; /** * Set the converted value of this property value, * after processed type conversion. */ public synchronized void setConvertedValue(@Nullable Object value) &#123; this.converted = true; this.convertedValue = value; &#125; /** * Return the converted value of this property value, * after processed type conversion. */ @Nullable public synchronized Object getConvertedValue() &#123; return this.convertedValue; &#125; @Override public boolean equals(@Nullable Object other) &#123; if (this == other) &#123; return true; &#125; if (!(other instanceof PropertyValue)) &#123; return false; &#125; PropertyValue otherPv = (PropertyValue) other; return (this.name.equals(otherPv.name) &amp;&amp; ObjectUtils.nullSafeEquals(this.value, otherPv.value) &amp;&amp; ObjectUtils.nullSafeEquals(getSource(), otherPv.getSource())); &#125; @Override public int hashCode() &#123; return this.name.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.value); &#125; @Override public String toString() &#123; return "bean property '" + this.name + "'"; &#125;&#125; 4.2 PropertyValues接口PropertyValues即PropertyValue的集合管理类,MutablePropertyValues是其实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface PropertyValues extends Iterable&lt;PropertyValue&gt; &#123; /** * 迭代器 * Return an &#123;@link Iterator&#125; over the property values. * @since 5.1 */ @Override default Iterator&lt;PropertyValue&gt; iterator() &#123; return Arrays.asList(getPropertyValues()).iterator(); &#125; /** * 并行遍历迭代器 * * Return a &#123;@link Spliterator&#125; over the property values. * @since 5.1 */ @Override default Spliterator&lt;PropertyValue&gt; spliterator() &#123; return Spliterators.spliterator(getPropertyValues(), 0); &#125; /** * Return a sequential &#123;@link Stream&#125; containing the property values. * @since 5.1 */ default Stream&lt;PropertyValue&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; /** * Return an array of the PropertyValue objects held in this object. */ PropertyValue[] getPropertyValues(); /** * Return the property value with the given name, if any. * @param propertyName the name to search for * @return the property value, or &#123;@code null&#125; if none */ @Nullable PropertyValue getPropertyValue(String propertyName); /** * Return the changes since the previous PropertyValues. * Subclasses should also override &#123;@code equals&#125;. * @param old old property values * @return the updated or new properties. * Return empty PropertyValues if there are no changes. * @see Object#equals */ PropertyValues changesSince(PropertyValues old); /** * Is there a property value (or other processing entry) for this property? * @param propertyName the name of the property we're interested in * @return whether there is a property value for this property */ boolean contains(String propertyName); /** * Does this holder not contain any PropertyValue objects at all? */ boolean isEmpty();&#125; 4.3 MutablePropertyValues类MutablePropertyValues实现了PropertyValues。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355public class MutablePropertyValues implements PropertyValues, Serializable &#123; private final List&lt;PropertyValue&gt; propertyValueList; @Nullable private Set&lt;String&gt; processedProperties; private volatile boolean converted = false; /** * Creates a new empty MutablePropertyValues object. * &lt;p&gt;Property values can be added with the &#123;@code add&#125; method. * @see #add(String, Object) */ public MutablePropertyValues() &#123; this.propertyValueList = new ArrayList&lt;&gt;(0); &#125; /** * Deep copy constructor. Guarantees PropertyValue references * are independent, although it can&apos;t deep copy objects currently * referenced by individual PropertyValue objects. * @param original the PropertyValues to copy * @see #addPropertyValues(PropertyValues) */ public MutablePropertyValues(@Nullable PropertyValues original) &#123; // We can optimize this because it&apos;s all new: // There is no replacement of existing property values. if (original != null) &#123; PropertyValue[] pvs = original.getPropertyValues(); this.propertyValueList = new ArrayList&lt;&gt;(pvs.length); for (PropertyValue pv : pvs) &#123; this.propertyValueList.add(new PropertyValue(pv)); &#125; &#125; else &#123; this.propertyValueList = new ArrayList&lt;&gt;(0); &#125; &#125; /** * Construct a new MutablePropertyValues object from a Map. * @param original a Map with property values keyed by property name Strings * @see #addPropertyValues(Map) */ public MutablePropertyValues(@Nullable Map&lt;?, ?&gt; original) &#123; // We can optimize this because it&apos;s all new: // There is no replacement of existing property values. if (original != null) &#123; this.propertyValueList = new ArrayList&lt;&gt;(original.size()); original.forEach((attrName, attrValue) -&gt; this.propertyValueList.add( new PropertyValue(attrName.toString(), attrValue))); &#125; else &#123; this.propertyValueList = new ArrayList&lt;&gt;(0); &#125; &#125; /** * Construct a new MutablePropertyValues object using the given List of * PropertyValue objects as-is. * &lt;p&gt;This is a constructor for advanced usage scenarios. * It is not intended for typical programmatic use. * @param propertyValueList a List of PropertyValue objects */ public MutablePropertyValues(@Nullable List&lt;PropertyValue&gt; propertyValueList) &#123; this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList&lt;&gt;()); &#125; /** * Return the underlying List of PropertyValue objects in its raw form. * The returned List can be modified directly, although this is not recommended. * &lt;p&gt;This is an accessor for optimized access to all PropertyValue objects. * It is not intended for typical programmatic use. */ public List&lt;PropertyValue&gt; getPropertyValueList() &#123; return this.propertyValueList; &#125; /** * Return the number of PropertyValue entries in the list. */ public int size() &#123; return this.propertyValueList.size(); &#125; /** * Copy all given PropertyValues into this object. Guarantees PropertyValue * references are independent, although it can&apos;t deep copy objects currently * referenced by individual PropertyValue objects. * @param other the PropertyValues to copy * @return this in order to allow for adding multiple property values in a chain */ public MutablePropertyValues addPropertyValues(@Nullable PropertyValues other) &#123; if (other != null) &#123; PropertyValue[] pvs = other.getPropertyValues(); for (PropertyValue pv : pvs) &#123; addPropertyValue(new PropertyValue(pv)); &#125; &#125; return this; &#125; /** * Add all property values from the given Map. * @param other a Map with property values keyed by property name, * which must be a String * @return this in order to allow for adding multiple property values in a chain */ public MutablePropertyValues addPropertyValues(@Nullable Map&lt;?, ?&gt; other) &#123; if (other != null) &#123; other.forEach((attrName, attrValue) -&gt; addPropertyValue( new PropertyValue(attrName.toString(), attrValue))); &#125; return this; &#125; /** * Add a PropertyValue object, replacing any existing one for the * corresponding property or getting merged with it (if applicable). * @param pv the PropertyValue object to add * @return this in order to allow for adding multiple property values in a chain */ public MutablePropertyValues addPropertyValue(PropertyValue pv) &#123; for (int i = 0; i &lt; this.propertyValueList.size(); i++) &#123; PropertyValue currentPv = this.propertyValueList.get(i); // 已经存在一个同名属性 replacing 或者 merged if (currentPv.getName().equals(pv.getName())) &#123; pv = mergeIfRequired(pv, currentPv); setPropertyValueAt(pv, i); return this; &#125; &#125; // 添加一个新的PropertyValue this.propertyValueList.add(pv); return this; &#125; /** * Overloaded version of &#123;@code addPropertyValue&#125; that takes * a property name and a property value. * &lt;p&gt;Note: As of Spring 3.0, we recommend using the more concise * and chaining-capable variant &#123;@link #add&#125;. * @param propertyName name of the property * @param propertyValue value of the property * @see #addPropertyValue(PropertyValue) */ public void addPropertyValue(String propertyName, Object propertyValue) &#123; addPropertyValue(new PropertyValue(propertyName, propertyValue)); &#125; /** * Add a PropertyValue object, replacing any existing one for the * corresponding property or getting merged with it (if applicable). * @param propertyName name of the property * @param propertyValue value of the property * @return this in order to allow for adding multiple property values in a chain */ public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) &#123; addPropertyValue(new PropertyValue(propertyName, propertyValue)); return this; &#125; /** * 修改指定位置的值 * * Modify a PropertyValue object held in this object. * Indexed from 0. */ public void setPropertyValueAt(PropertyValue pv, int i) &#123; this.propertyValueList.set(i, pv); &#125; /** * Merges the value of the supplied &apos;new&apos; &#123;@link PropertyValue&#125; with that of * the current &#123;@link PropertyValue&#125; if merging is supported and enabled. * @see Mergeable */ private PropertyValue mergeIfRequired(PropertyValue newPv, PropertyValue currentPv) &#123; Object value = newPv.getValue(); if (value instanceof Mergeable) &#123; Mergeable mergeable = (Mergeable) value; if (mergeable.isMergeEnabled()) &#123; // 可以合并则合并 Object merged = mergeable.merge(currentPv.getValue()); return new PropertyValue(newPv.getName(), merged); &#125; &#125; //不可以合并，返回新的PropertyValue return newPv; &#125; /** * 根据值来移除 * Remove the given PropertyValue, if contained. * @param pv the PropertyValue to remove */ public void removePropertyValue(PropertyValue pv) &#123; this.propertyValueList.remove(pv); &#125; /** * 根据名来移除 * * Overloaded version of &#123;@code removePropertyValue&#125; that takes a property name. * @param propertyName name of the property * @see #removePropertyValue(PropertyValue) */ public void removePropertyValue(String propertyName) &#123; //先拿到值，再根据值来移除 this.propertyValueList.remove(getPropertyValue(propertyName)); &#125; @Override public Iterator&lt;PropertyValue&gt; iterator() &#123; return Collections.unmodifiableList(this.propertyValueList).iterator(); &#125; @Override public Spliterator&lt;PropertyValue&gt; spliterator() &#123; return Spliterators.spliterator(this.propertyValueList, 0); &#125; @Override public Stream&lt;PropertyValue&gt; stream() &#123; return this.propertyValueList.stream(); &#125; @Override public PropertyValue[] getPropertyValues() &#123; return this.propertyValueList.toArray(new PropertyValue[0]); &#125; @Override @Nullable public PropertyValue getPropertyValue(String propertyName) &#123; for (PropertyValue pv : this.propertyValueList) &#123; if (pv.getName().equals(propertyName)) &#123; return pv; &#125; &#125; return null; &#125; /** * Get the raw property value, if any. * @param propertyName the name to search for * @return the raw property value, or &#123;@code null&#125; if none found * @since 4.0 * @see #getPropertyValue(String) * @see PropertyValue#getValue() */ @Nullable public Object get(String propertyName) &#123; PropertyValue pv = getPropertyValue(propertyName); return (pv != null ? pv.getValue() : null); &#125; @Override public PropertyValues changesSince(PropertyValues old) &#123; MutablePropertyValues changes = new MutablePropertyValues(); if (old == this) &#123; return changes; &#125; // for each property value in the new set for (PropertyValue newPv : this.propertyValueList) &#123; // if there wasn&apos;t an old one, add it PropertyValue pvOld = old.getPropertyValue(newPv.getName()); if (pvOld == null || !pvOld.equals(newPv)) &#123; changes.addPropertyValue(newPv); &#125; &#125; return changes; &#125; @Override public boolean contains(String propertyName) &#123; return (getPropertyValue(propertyName) != null || (this.processedProperties != null &amp;&amp; this.processedProperties.contains(propertyName))); &#125; @Override public boolean isEmpty() &#123; return this.propertyValueList.isEmpty(); &#125; /** * Register the specified property as &quot;processed&quot; in the sense * of some processor calling the corresponding setter method * outside of the PropertyValue(s) mechanism. * &lt;p&gt;This will lead to &#123;@code true&#125; being returned from * a &#123;@link #contains&#125; call for the specified property. * @param propertyName the name of the property. */ public void registerProcessedProperty(String propertyName) &#123; if (this.processedProperties == null) &#123; this.processedProperties = new HashSet&lt;&gt;(4); &#125; this.processedProperties.add(propertyName); &#125; /** * Clear the &quot;processed&quot; registration of the given property, if any. * @since 3.2.13 */ public void clearProcessedProperty(String propertyName) &#123; if (this.processedProperties != null) &#123; this.processedProperties.remove(propertyName); &#125; &#125; /** * Mark this holder as containing converted values only * (i.e. no runtime resolution needed anymore). */ public void setConverted() &#123; this.converted = true; &#125; /** * Return whether this holder contains converted values only (&#123;@code true&#125;), * or whether the values still need to be converted (&#123;@code false&#125;). */ public boolean isConverted() &#123; return this.converted; &#125; @Override public boolean equals(@Nullable Object other) &#123; return (this == other || (other instanceof MutablePropertyValues &amp;&amp; this.propertyValueList.equals(((MutablePropertyValues) other).propertyValueList))); &#125; @Override public int hashCode() &#123; return this.propertyValueList.hashCode(); &#125; @Override public String toString() &#123; PropertyValue[] pvs = getPropertyValues(); if (pvs.length &gt; 0) &#123; return &quot;PropertyValues: length=&quot; + pvs.length + &quot;; &quot; + StringUtils.arrayToDelimitedString(pvs, &quot;; &quot;); &#125; return &quot;PropertyValues: length=0&quot;; &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析4-BeanFactory与DefaultListableBeanFactory]]></title>
    <url>%2F2019%2F08%2F31%2FSpring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-BeanFactory%E4%B8%8EDefaultListableBeanFactory%2F</url>
    <content type="text"><![CDATA[Spring Beans模块是Spring中的一个重要模块，所有的应用都需要使用，功能主要有 访问配置文件 创建和管理bean 进行IoC/DI相关操作 1. BeanFactory接口BeanFactory顾名思义就是生产bean的工厂。 首先来看BeanFactory定义： 123456789101112131415161718192021222324252627282930313233343536373839public interface BeanFactory &#123; /** * FactoryBean这种在注入bean的时候会在beanName前添加一个"&amp;"修饰符 * 例如，如果名为myJndiObject的bean是FactoryBean， * 则获取＆myJndiObject将返回这个工厂，而不是工厂返回的实例。 */ String FACTORY_BEAN_PREFIX = "&amp;"; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType); &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType); boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name);&#125; 2.DefaultListableBeanFactoryDefaultListableBeanFactory间接实现了BeanFactory，是整个bean加载的核心部分，是Spring注册以及加载bean的默认实现。 DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory，并实现了ConfigurableListableBeanFactory，以及BeanDefinitionRegister接口。 2.1首先看下类结构图和类继承关系 各个接口和类的作用： BeanFactory：定义获取bean及bean的各种属性 AliasRegistry接口：定义对alias的简单增删改查等操作 SimpleAliasRegistry：主要使用map作为alias的缓存，并对接口AliasRegister进行实现 SingletonBeanRegistry：定义对单例的注册及获取 DefaultSingletonBeanRegistry：对接口SingletonBeanRegistry各函数的实现 BeanDefinitionRegistry：定义对BeanDefinition的各种增删改查操作 ListableBeanFactory：根据各种条件获取bean的配置清单（可以预加载bean definition） HierarchicalBeanFactory：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加对parentFactory的支持 FactoryBeanRegisterSupport：DefaultSingletonBeanRegistry基础上增加了对FactoryBean的特殊处理功能。 ConfigurableBeanFactory：提供配置Factory的各种方法 AbstractBeanFactory：综合FactoryBeanRegisterSupport和ConfigurableBeanFactory的功能 AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器 AbstractAutowireCapableBeanFactory：综合AbstractBeanFactory并AutowireCapableBeanFactory接口进行实现 ConfigurableListableBeanFactory：Bean配置清单，指定忽略类型及接口等 DefaultListableBeanFactory：综合上面所有功能，主要对Bean注册后的处理。 2.2 主要父接口和父类详细介绍2.2.1 AliasRegiser接口、SimpleAliasRegistry类、SingletonBeanRegistry接口、DefaultSingletonBeanRegistry类见上一篇博文 2.2.2 BeanDefinitionRegistry接口定义对BeanDefinition的各种增删改查操作,并且继承了AliasRegistry接口 123456789101112131415161718192021222324252627282930313233343536373839public interface BeanDefinitionRegistry extends AliasRegistry &#123; /** * 注册一个新的BeanDefinition */ void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; /** * 根据给定的名字，移除注册的BeanDefinition */ void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; /** * 根据给定名字，查找注册的BeanDefinition */ BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; /** * 检查registry中是否包含一个给定名字的BeanDefinition */ boolean containsBeanDefinition(String beanName); /** * 返回registry中注册的所有BeanDefinition的名字数组 */ String[] getBeanDefinitionNames(); /** * 返回registry中注册的所有BeanDefinition的个数 */ int getBeanDefinitionCount(); /** * 判断指定的名字是否已经在registry使用了 */ boolean isBeanNameInUse(String beanName);&#125; 2.2.3 ListableBeanFactory接口ListableBeanFactory是BeanFactory接口的扩展接口，它可以枚举所有的bean实例，而不是客户端通过名称一个一个的查询得出所有的实例。要预加载所有的bean定义的BeanFactory可以实现这个接口。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring ImportBeanDefinitionRegistrar介绍.md]]></title>
    <url>%2F2019%2F08%2F22%2FSpring%20ImportBeanDefinitionRegistrar%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文需要介绍的ImportBeanDefinitionRegistrar的用法和作用跟ImportSelector类似。 唯一的不同点是ImportBeanDefinitionRegistrar的接口方法void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)的返回类型是void，且多了一个BeanDefinitionRegistry类型的参数，它允许我们直接通过BeanDefinitionRegistry对象注册bean。 一.源码ImportBeanDefinitionRegistrar源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.springframework.context.annotation;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;import org.springframework.core.type.AnnotationMetadata;/** * Interface to be implemented by types that register additional bean definitions when * processing @&#123;@link Configuration&#125; classes. Useful when operating at the bean definition * level (as opposed to &#123;@code @Bean&#125; method/instance level) is desired or necessary. * * &lt;p&gt;Along with &#123;@code @Configuration&#125; and &#123;@link ImportSelector&#125;, classes of this type * may be provided to the @&#123;@link Import&#125; annotation (or may also be returned from an * &#123;@code ImportSelector&#125;). * * &lt;p&gt;An &#123;@link ImportBeanDefinitionRegistrar&#125; may implement any of the following * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective * methods will be called prior to &#123;@link #registerBeanDefinitions&#125;: * &lt;ul&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125; * &lt;/ul&gt; * * &lt;p&gt;See implementations and associated unit tests for usage examples. * * @author Chris Beams * @since 3.1 * @see Import * @see ImportSelector * @see Configuration */public interface ImportBeanDefinitionRegistrar &#123; /** * Register bean definitions as necessary based on the given annotation metadata of * the importing &#123;@code @Configuration&#125; class. * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125; * class processing. * @param importingClassMetadata annotation metadata of the importing class * @param registry current bean definition registry */ public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&#125; 二. 示例1.示例一为了扫描并注册HelloService类型的bean，我们可以自定义如下ImportBeanDefinitionRegistrar实现类。 在实现类中可以使用ClassPathBeanDefinitionScanner进行扫描并自动注册，它是ClassPathScanningCandidateComponentProvider的子类，所以还是可以添加相同的TypeFilter，然后通过scanner.scan(basePackages)扫描指定的basePackage下满足条件的Class并注册它们为bean。 1234567891011121314151617181920212223242526272829303132package com.zhj.importBeanDefinitionRegistrar;import com.zhj.service.HelloService;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AssignableTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.Map;/** * @author zhj on 2019-08-22. */public class HelloImportBeanDefinitionRegistrar1 implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName()); String[] basePackages = (String[]) annotationAttributes.get("basePackages"); ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); scanner.scan(basePackages); &#125;&#125; 此时我们的@Configuration配置类可以进行如下定义。 1234567891011121314package com.zhj.importBeanDefinitionRegistrar;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** * @author zhj on 2019-08-22. */@Configuration@ComponentScan("com.zhj.service.impl")@Import(HelloImportBeanDefinitionRegistrar.class)public class HelloConfiguration1 &#123;&#125; 2.自定义注解为它定义一个特定的注解也是可以的，比如下面代码为HelloImportBeanDefinitionRegistrar定义了@HelloScan，其value属性和basePackages属性互为别名，用于指定需要扫描的basePackage。 1234567891011121314151617181920212223package com.zhj.importBeanDefinitionRegistrar;import org.springframework.context.annotation.Import;import org.springframework.core.annotation.AliasFor;import java.lang.annotation.*;/** * @author zhj on 2019-08-22. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Import(HelloImportBeanDefinitionRegistrar2.class)public @interface HelloScan &#123; @AliasFor("value") String[] basePackages() default &#123;&#125;; @AliasFor("basePackages") String[] value() default &#123;&#125;;&#125; 为了满足@HelloScan指定扫描的basePackage的需求，我们的HelloImportBeanDefinitionRegistrar需要改造为如下这样。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.zhj.importBeanDefinitionRegistrar;import com.zhj.service.HelloService;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.context.annotation.ClassPathBeanDefinitionScanner;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AssignableTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.Map;/** * @author zhj on 2019-08-22. */public class HelloImportBeanDefinitionRegistrar2 implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(HelloScan.class.getName()); String[] basePackages = (String[]) annotationAttributes.get("basePackages"); if (basePackages == null || basePackages.length == 0) &#123;//HelloScan的basePackages默认为空数组 String basePackage = null; try &#123; basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; basePackages = new String[] &#123;basePackage&#125;; &#125; for (int i = 0; i &lt; basePackages.length; i++) &#123; System.out.println("HelloScan basePackage："+basePackages[i]); &#125; ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); scanner.scan(basePackages); &#125;&#125; 此时我们的HelloConfiguration可以定义为如下这样，它的效果和之前是一模一样的。 1234567891011package com.zhj.importBeanDefinitionRegistrar;import org.springframework.context.annotation.Configuration;/** * @author zhj on 2019-08-22. */@Configuration@HelloScan("com.zhj.service.impl")public class HelloConfiguration2 &#123;&#125; Test123456789101112131415161718192021222324252627282930313233343536package com.zhj.importBeanDefinitionRegistrar;import com.zhj.service.HelloService;import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import java.util.Map;/** * @author zhj on 2019-08-22. */public class HelloImportSelectorTest &#123; @Test public void test1()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfiguration1.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125; &#125; @Test public void test2()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfiguration2.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring ImportSelector介绍.md]]></title>
    <url>%2F2019%2F08%2F22%2FSpring%20ImportSelector%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ImportSelecto的用途比较简单，可以根据启动的相关环境配置来决定让哪些类能够被Spring容器初始化。 Spring中，在@Configuration标注的Class（配置类）上可以使用@Import引入其它的配置类，其实它还可以引入org.springframework.context.annotation.ImportSelector的实现类。 一.ImportSelector接口说明ImportSelector接口只定义了一个selectImports()，用于指定需要注册为bean的Class名称。 当在@Configuration标注的Class上使用@Import引入了一个ImportSelector实现类后，会把实现类中返回的Class名称都定义为bean。 1.源码解读下面是ImportSelector的源码 12345678910111213141516171819202122232425262728293031323334353637383940package org.springframework.context.annotation;import org.springframework.core.type.AnnotationMetadata;/** * Interface to be implemented by types that determine which @&#123;@link Configuration&#125; * class(es) should be imported based on a given selection criteria, usually one or more * annotation attributes. * * &lt;p&gt;An &#123;@link ImportSelector&#125; may implement any of the following * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective * methods will be called prior to &#123;@link #selectImports&#125;: * &lt;ul&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;@code @Import&#125; * annotations, however, it is also possible to defer selection of imports until all * &#123;@code @Configuration&#125; classes have been processed (see &#123;@link DeferredImportSelector&#125; * for details). * * @author Chris Beams * @since 3.1 * @see DeferredImportSelector * @see Import * @see ImportBeanDefinitionRegistrar * @see Configuration */public interface ImportSelector &#123; /** * Select and return the names of which class(es) should be imported based on * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class. */ String[] selectImports(AnnotationMetadata importingClassMetadata);&#125; 接口文档上写明，主要作用是收集需要导入的配置类，如果该接口的实现类同时实现下列接 EnvironmentAware BeanFactoryAware BeanClassLoaderAware ResourceLoaderAware 那么在调用其selectImports方法之前先调用上述接口中对应的方法，如果需要在所有的@Configuration处理完再导入时可以实现DeferredImportSelector接口。 2.举例说明2.1 定义一个接口以及2个实现类HelloService.java 12345678package com.zhj.service;/** * @author zhj on 2019-08-22. */public interface HelloService &#123; void doSomething();&#125; HelloServiceImplA.java 1234567891011121314package com.zhj.service.impl;import com.zhj.service.HelloService;/** * @author zhj on 2019-08-22. */public class HelloServiceImplA implements HelloService &#123; @Override public void doSomething() &#123; System.out.println("Hello A"); &#125;&#125; HelloServiceImplB.java 1234567891011121314package com.zhj.service.impl;import com.zhj.service.HelloService;/** * @author zhj on 2019-08-22. */public class HelloServiceImplB implements HelloService &#123; @Override public void doSomething() &#123; System.out.println("Hello B"); &#125;&#125; 2.2 ImportSelector实现2.2.1 实现一定义了一个ImportSelector实现类HelloImportSelector1，直接指定了需要把HelloService接口的实现类HelloServiceA和HelloServiceB定义为bean。 1234567891011121314151617package com.zhj.importSelector;import com.zhj.service.impl.HelloServiceImplA;import com.zhj.service.impl.HelloServiceImplB;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;/** * @author zhj on 2019-08-22. */public class HelloImportSelector1 implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;HelloServiceImplA.class.getName(), HelloServiceImplB.class.getName()&#125;; &#125;&#125; 然后定义了@Configuration配置类HelloConfiguration1，指定了@Import的是HelloImportSelector1。 HelloConfiguration1.java 12345678910111213package com.zhj.importSelector;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** * @author zhj on 2019-08-22. */@Configuration@Import(HelloImportSelector1.class)public class HelloConfiguration1 &#123;&#125; 这样当加载配置类HelloConfiguration1的时候会一并把HelloServiceA和HelloServiceB注册为Spring bean。可以 测试： 12345678910@Testpublic void test1()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfiguration1.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125;&#125; 输出： 1234com.zhj.service.impl.HelloServiceImplAHello Acom.zhj.service.impl.HelloServiceImplBHello B 2.2.2 直接在HelloConfiguration中定义bean或者import。看到这里可能你会觉得其实它也没什么用，因为整一个ImportSelector实现类那么麻烦，还不如直接在HelloConfiguration中定义bean或者import。 在不引入ImportSelector的情况下，下面的两种方式都可以达到相同的效果。 12345678910111213141516171819202122//直接在HelloConfiguration中import@Configuration@Import(&#123;HelloServiceImplA.class, HelloServiceImplB.class&#125;)public class HelloConfigurationDirect &#123;&#125;//直接在HelloConfiguration中定义bean@Configurationpublic class HelloConfigurationDefineBean &#123; @Bean public HelloServiceImplA helloServiceImplA()&#123; return new HelloServiceImplA(); &#125; @Bean public HelloServiceImplB helloServiceImplB()&#123; return new HelloServiceImplB(); &#125;&#125; 测试： 123456789101112131415161718192021@Testpublic void testDirect()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfigurationDirect.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125;&#125;@Testpublic void testDefineBean()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfigurationDefineBean.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125;&#125; 如果直接是固定的bean定义，那完全可以用上面的方式代替。 但如果需要动态的带有逻辑性的定义bean，则使用ImportSelector还是很有用处的。因为在它的selectImports()你可以实现各种获取bean Class的逻辑，通过其参数AnnotationMetadata importingClassMetadata可以获取到@Import标注的Class的各种信息，包括其Class名称，实现的接口名称、父类名称、添加的其它注解等信息，通过这些额外的信息可以辅助我们选择需要定义为Spring bean的Class名称。 2.2.3 @ComponentScan扫描方法现假设我们在HelloConfiguration上使用了@ComponentScan进行bean定义扫描我们期望HelloImportSelector也可以扫描@ComponentScan指定的Package下HelloService实现类并把它们定义为bean，则HelloImportSelector和HelloConfiguration可以改为如下这样： HelloConfigurationWithScan.java 1234567891011121314package com.zhj.importSelector;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** * @author zhj on 2019-08-22. */@Configuration@ComponentScan("com.zhj.service.impl")@Import(HelloImportSelector4.class)public class HelloConfigurationWithScan &#123;&#125; HelloImportSelectorWithScan.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.zhj.importSelector;import com.zhj.service.HelloService;import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.filter.AssignableTypeFilter;import org.springframework.core.type.filter.TypeFilter;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * @author zhj on 2019-08-22. */public class HelloImportSelectorWithScan implements ImportSelector &#123; /** * 可以看到在HelloImportSelector的实现中获取了HelloConfiguration类上标注的@ComponentScan的basePackages属性值 * 并使用ClassPathScanningCandidateComponentProvider进行了扫描。 * * 可能有的时候你不希望依赖于配置类上的@ComponentScan，而期望直接扫描配置类所在的包。 * 此时可以通过importingClassMetadata.getClassName()获取配置类的Class名称，进而获取其package名称。 * * @param importingClassMetadata * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName()); String[] basePackages = (String[]) annotationAttributes.get("basePackages"); for (int i = 0; i &lt; basePackages.length; i++) &#123; System.out.println("basePackages_"+i+"："+basePackages[i]); &#125; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); Set&lt;String&gt; classes = new HashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); &#125; //set转换为array return classes.toArray(new String[classes.size()]); &#125;&#125; 测试： 12345678910@Testpublic void testWithScan()&#123; AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(HelloConfigurationWithScan.class); Map&lt;String,HelloService&gt; helloServices = annotationConfigApplicationContext.getBeansOfType(HelloService.class); for (String key : helloServices.keySet())&#123; System.out.println(key); helloServices.get(key).doSomething(); &#125;&#125; 2.2.4 期望直接扫描配置类所在的包可以看到在HelloImportSelector的实现中获取了HelloConfiguration类上标注的@ComponentScan的basePackages属性值，并使用ClassPathScanningCandidateComponentProvider进行了扫描。可能有的时候你不希望依赖于配置类上的@ComponentScan，而期望直接扫描配置类所在的包。 此时可以通过importingClassMetadata.getClassName()获取配置类的Class名称，进而获取其package名称。 12345678910111213141516171819202122232425@Overridepublic String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; String packageName = null; try &#123; packageName = Class.forName(importingClassMetadata.getClassName()).getPackage().getName(); System.out.println("packageName="+packageName); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; String[] basePackages = new String[] &#123;packageName&#125;; for (int i = 0; i &lt; basePackages.length; i++) &#123; System.out.println("4_basePackages_"+i+"："+basePackages[i]); &#125; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); Set&lt;String&gt; classes = new HashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); &#125; return classes.toArray(new String[classes.size()]);&#125; 2.2.5 更通用一点的做法更通用一点的做法可能你还是期望扫描的package跟@Configuration上的@ComponentScan的basePackages保持一致或者在没有指定@ComponentScan时扫描配置类所在的package。 @ComponentScan`的basePackages如果没有指定，默认是把配置类当前所在的package当做basePackage。所以为了满足这些需求，我们的HelloImportSelector可以定义为如下这样: 12345678910111213141516171819202122232425@Overridepublic String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; String[] basePackages = null; if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName()); basePackages = (String[]) annotationAttributes.get("basePackages"); &#125; if (basePackages == null || basePackages.length == 0) &#123;//ComponentScan的basePackages默认为空数组 String basePackage = null; try &#123; basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; basePackages = new String[] &#123;basePackage&#125;; &#125; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); Set&lt;String&gt; classes = new HashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); &#125; return classes.toArray(new String[classes.size()]);&#125; 2.3 为ImportSelector定义特定的注解当我们觉得在@Configuration配置类上使用@Import(HelloImportSelector.class)太麻烦，或者是需要在ImportSelector实现类中使用一些特定的配置时就可以考虑为ImportSelector实现类定义一个特定的注解，在该注解上使用@Import(HelloImportSelector.class)。 如下针对上面的HelloImportSelector定义了一个@HelloServiceScan注解，用于扫描HelloService实现类。 12345678910111213141516171819202122232425package com.zhj.importSelector.annotation;import com.zhj.importSelector.HelloImportSelector1;import org.springframework.context.annotation.Import;import org.springframework.core.annotation.AliasFor;import java.lang.annotation.*;/** * @author zhj on 2019-08-22. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Import(HelloImportSelector1.class)public @interface HelloServiceScan &#123; @AliasFor("value") String[] basePackages() default &#123;&#125;; @AliasFor("basePackages") String[] value() default &#123;&#125;;&#125; 此时，我们的HelloConfiguration类可以改为如下这样，效果跟之前的一样的。 123456789101112package com.zhj.importSelector;import com.zhj.importSelector.annotation.HelloServiceScan;import org.springframework.context.annotation.Configuration;/** * @author zhj on 2019-08-22. */@Configuration@HelloServiceScan("com.zhj.service.impl")public class HelloScanHelloConfiguration &#123;&#125; 这样HelloImportSelector在进行bean扫描时可以通过@HelloServiceScan的basePackages属性获取需要扫描的basePackage。 123456789101112131415161718192021222324252627@Overridepublic String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(HelloServiceScan.class.getName()); String[] basePackages = (String[]) annotationAttributes.get("basePackages"); //HelloServiceScan的basePackages默认为空数组 if (basePackages == null || basePackages.length == 0) &#123; String basePackage = null; try &#123; basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; basePackages = new String[] &#123;basePackage&#125;; &#125; ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false); TypeFilter helloServiceFilter = new AssignableTypeFilter(HelloService.class); scanner.addIncludeFilter(helloServiceFilter); Set&lt;String&gt; classes = new HashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classes.add(beanDefinition.getBeanClassName())); &#125; return classes.toArray(new String[classes.size()]);&#125; 参考博文：https://www.iteye.com/blog/elim-2428994]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上安装Redis]]></title>
    <url>%2F2019%2F06%2F24%2FMac%E4%B8%8A%E5%AE%89%E8%A3%85Redis%2F</url>
    <content type="text"><![CDATA[安装redisredis安装有两种方式：下载源码编译安装、使用homebrew安装。 通过homebrew安装redis 12brew install redis 配置文件安装完成后redis默认的配置文件redis.conf位于 /usr/local/etc 同时，redis-sentinel.conf也在这里。 使用cat命令查看redis.conf： 12cat /usr/local/etc/redis.conf 包含以下内容(删除了大部分内容)： 12345678910111213141516171819202122# Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf # Accept connections on the specified port, default is 6379 (IANA #815344). # If port 0 is specified Redis will not listen on a TCP socket. port 6379 # TCP listen() backlog. tcp-backlog 511 #The working directory dir /usr/local/var/db/redis/ 根据以上内容,如果启动时不指定配置文件,redis会使用程序中内置的默认配置.但是只有在开发和测试阶段才考虑使用内置的默认配置，正式环境最好还是提供配置文件，并且一般命名为redis.conf 启动redis-server如果需要给redis服务端指定配置文件，启动命令应该是这样的: 12redis-server /usr/local/etc/redis.conf 终端输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474846286:C 28 Feb 2019 11:36:55.966 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 46286:C 28 Feb 2019 11:36:55.966 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=46286, just started 46286:C 28 Feb 2019 11:36:55.966 # Configuration loaded 46286:M 28 Feb 2019 11:36:55.967 * Increased maximum number of open files to 10032 (it was originally set to 4864). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.3 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 46286 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 46286:M 28 Feb 2019 11:36:55.968 # Server initialized 46286:M 28 Feb 2019 11:36:55.969 * DB loaded from disk: 0.000 seconds 46286:M 28 Feb 2019 11:36:55.969 * Ready to accept connections 可以看出redis服务器启动成功，并在监听6379端口的网络连接。 注意: 使用命令$ redis-server也可以启动,此时并不会加载任何配置文件,使用的是程序中内置(built-in)的默认配置. 检查redis服务是否启动重新打开一个终端窗口，输入命令 12redis-cli ping 该终端输出 12PONG 说明服务器运作正常。 关闭redis方法1在执行启动命令的终端窗口使用ctrl+c,此时第一个窗口输出 1234567891011121314^C46286:signal-handler (1551325146) Received SIGINT scheduling shutdown... 46286:M 28 Feb 2019 11:39:06.432 # User requested shutdown... 46286:M 28 Feb 2019 11:39:06.432 * Saving the final RDB snapshot before exiting. 46286:M 28 Feb 2019 11:39:06.434 * DB saved on disk 46286:M 28 Feb 2019 11:39:06.434 * Removing the pid file. 46286:M 28 Feb 2019 11:39:06.434 # Redis is now ready to exit, bye bye... zhuhaijundeMacBook-Pro:redis apple$ 方法2在另外一个终端窗口执行redis-cli shutdown,此时第一个窗口输出 1234567891046288:M 28 Feb 2019 11:40:16.348 # User requested shutdown... 46288:M 28 Feb 2019 11:40:16.348 * Saving the final RDB snapshot before exiting. 46288:M 28 Feb 2019 11:40:16.349 * DB saved on disk 46288:M 28 Feb 2019 11:40:16.349 * Removing the pid file. 46288:M 28 Feb 2019 11:40:16.349 # Redis is now ready to exit, bye bye...]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js utils]]></title>
    <url>%2F2019%2F06%2F17%2Fjs-utils%2F</url>
    <content type="text"><![CDATA[js 时间戳转时间间隔123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 时间转为时间戳function date2timestamp(datetime) &#123; var timestamp = new Date(Date.parse(datetime)); timestamp = timestamp.getTime(); timestamp = timestamp / 1000; return timestamp;&#125;// 时间戳转时间function timestamp2date(timestamp, mode) &#123; if (parseInt(timestamp) &gt; 999999999999)&#123; timestamp /= 1000; &#125; var tt = new Date(parseInt(timestamp) * 1000).toLocaleString().replace(/:\d&#123;1,2&#125;$/, ' ').replace(/年|月/g, "-").replace(/日/g, " ").replace(/上午/g, "").replace(/下午/g, ""); var date_arr = tt.split(" "); if (mode == 3) &#123; var minute = 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var current_timestamp = parseInt(Date.parse(new Date()) / 1000); var diffValue = current_timestamp - timestamp; var monthC = diffValue / month; var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; /** * 2小时内--&gt; 刚刚 * 2小时-24小时内 --&gt; *小时前 * 超过24小时-1月内 --&gt; **天前 * 超过1个月-1年内 --&gt; *月前 * 超过1年 --&gt; 1年前 */ if (monthC &gt; 12)&#123; result = 1 + "年前"; &#125; else if (monthC &gt;= 1) &#123; result = parseInt(monthC) + "月前"; &#125; else if (dayC &gt;= 1) &#123; result = parseInt(dayC) + "天前"; &#125; else if (hourC &gt;= 2) &#123; result = parseInt(hourC) + "小时前"; &#125; else&#123; result = "刚刚"; &#125; return result; &#125; if (mode == 2) &#123; var current_timestamp = parseInt(Date.parse(new Date()) / 1000); if ((current_timestamp - timestamp) &gt; 7 * 24 * 60 * 60) &#123; // 一周之前，显示日期 return date_arr[0]; &#125; else &#123; var d = new Date(); var date = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate(); var b_date = date2timestamp(date + " 00:00:00"); var e_date = date2timestamp(date + " 23:59:59"); if (parseInt(timestamp) &gt; parseInt(b_date) &amp;&amp; parseInt(timestamp) &lt; parseInt(e_date)) &#123; // 今天,只显示时间 return date_arr[1]; &#125; if (parseInt(timestamp) &gt; parseInt(b_date - 24 * 60 * 60) &amp;&amp; parseInt(timestamp) &lt; parseInt(e_date - 24 * 60 * 60)) &#123; // 昨天，显示昨天 return "昨天"; &#125; // 显示周几 var days = new Array("星期日","星期一","星期二","星期三","星期四","星期五","星期六"); var day = new Date(date_arr[0]).getDay(); return days[day]; &#125; &#125; if (mode == 1) &#123; // 如果是当天，就不显示日期 var d = new Date(); var date = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate(); var b_date = date2timestamp(date + " 00:00:00"); var e_date = date2timestamp(date + " 23:59:59"); if (parseInt(timestamp) &gt; parseInt(b_date) &amp;&amp; parseInt(timestamp) &lt; parseInt(e_date)) &#123; return date_arr[1]; &#125; return tt; &#125; return tt;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程交替打印ABC的多种实现方法]]></title>
    <url>%2F2019%2F03%2F14%2F%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。 1、Synchronized同步法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ThreadABC_Notify &#123; static class MyThread extends Thread&#123; private String name; private Object prev; private Object self; public MyThread(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; /** * wait() 与 notify/notifyAll() 是Object类的方法，在执行两个方法时，要先获得锁。 * 当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。 * 当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。 * 从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。 * 所以在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。 */ @Override public void run() &#123; int count = 10 ; while (count &gt; 0 )&#123; synchronized (prev) &#123; synchronized (self)&#123; System.out.println(name); count-- ; self.notifyAll(); // 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。 &#125; try &#123; if (count == 0)&#123; // 如果count==0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。 prev.notifyAll(); &#125;else&#123; // 立即释放 prev锁，当前线程休眠，等待唤醒 prev.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); Thread A = new MyThread("A",c,a); Thread B = new MyThread("B",a,b); Thread C = new MyThread("C",b,c); A.start(); Thread.sleep(10); B.start(); Thread.sleep(10); C.start(); &#125;&#125; 2、Lock Condition 法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * private Lock lock = new ReentrantLock(); * private Condition condition = lock.newCondition(); * condition.await();//this.wait(); * condition.signal();//this.notify(); * condition.signalAll();//this.notifyAll(); * */public class ThreadABC_Condition &#123; private static Lock lock = new ReentrantLock(); private static Condition A = lock.newCondition(); private static Condition B = lock.newCondition(); private static Condition C = lock.newCondition(); private static int count = 0 ; static class ThreadA extends Thread &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; while (count % 3 != 0 )&#123; A.await(); &#125; System.out.print("A"); count++; B.signal(); // A执行完唤醒B线程 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; static class ThreadB extends Thread &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; while (count % 3 != 1 )&#123; B.await(); &#125; System.out.print("B"); count++; C.signal(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; static class ThreadC extends Thread &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; while (count % 3 != 2 )&#123; C.await(); &#125; System.out.print("C"); count++; A.signal(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; new ThreadB().start(); new ThreadA().start(); new ThreadC().start(); &#125;&#125; 3、Semaphore法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.concurrent.Semaphore;/** * Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。 * * public Semaphore(int permits); * 其中参数permits就是允许同时运行的线程数目; * * Semaphore semaphore = new Semaphore(10,true); * semaphore.acquire(); * //do something here * semaphore.release(); */public class ThreadABC_Semaphore &#123; private static Semaphore A = new Semaphore(1); private static Semaphore B = new Semaphore(0); private static Semaphore C = new Semaphore(0); static class ThreadA extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; A.acquire(); System.out.print("A"); B.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; static class ThreadB extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; B.acquire(); System.out.print("B"); C.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; static class ThreadC extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; C.acquire(); System.out.print("C"); A.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Thread a = new ThreadA(); Thread b = new ThreadB(); Thread c = new ThreadC(); a.start(); c.start(); b.start(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 并发 线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机 IV]]></title>
    <url>%2F2019%2F01%2F23%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV%2F</url>
    <content type="text"><![CDATA[1 算法描述给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2: 1234输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 2 解法当k大于等于数组长度一半时, 问题退化为贪心问题此时采用买卖股票的最佳时机 II的贪心方法解决,可以大幅提升时间性能, 对于其他的k, 可以采用 买卖股票的最佳时机 III的方法来解决, 在III中定义了两次买入和卖出时最大收益的变量, 在这里就是k组这样的变量, 即问题IV是对问题III的推广, t[i][0]和t[i][1]分别表示第i比交易买入和卖出时各自的最大收益。 12345678910111213141516171819202122232425262728293031323334353637public int maxProfit(int k, int[] prices) &#123; if (prices != null &amp;&amp; prices.length &gt; 1 &amp;&amp; k &gt; 0 )&#123; if (k &gt;= prices.length / 2 ) return greedy(prices); //t[i][0]和t[i][1]分别表示第i笔交易买入和卖出时 各自的最大收益 int[][] t = new int[k][2]; for(int i = 0; i &lt; k; ++i) t[i][0] = Integer.MIN_VALUE; for (int p : prices)&#123; //第1次买 t[0][0] = Math.max( t[0][0] , -p); t[0][1] = Math.max( t[0][1] , t[0][0] + p); int i = 1 ; while(i &lt; k )&#123; t[i][0] = Math.max( t[i][0] , t[i-1][1] -p); t[i][1] = Math.max( t[i][1] , t[i][0] + p); i++; &#125; &#125; return t[k-1][1]; &#125; return 0; &#125; private int greedy(int[] prices) &#123; int max = 0; for(int i = 1; i &lt; prices.length; ++i) &#123; if(prices[i] &gt; prices[i-1]) max += prices[i] - prices[i-1]; &#125; return max; &#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机 III]]></title>
    <url>%2F2019%2F01%2F23%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III%2F</url>
    <content type="text"><![CDATA[1 算法描述给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 2 解法对于任意一天考虑 2 个变量: buy[times-1] sell[times-1] 买入时最大收益，卖出时候最大收益 buy[times-1]: 在该天第 times - 1 次买入股票可获得的最大收益sell[times-1]: 在该天第 times -1 次卖出股票可获得的最大收益 buy[times]: 在该天第 times 次买入股票可获得的最大收益sell[times]: 在该天第 times 次卖出股票可获得的最大收益 分别对四个变量进行相应的更新, 最后 一次卖出sell[maxTimes-1] 就是最大收益值(sell[times] &gt;= sell[times-1]) 123456789101112131415161718public int maxProfit(int[] prices) &#123; if (prices != null &amp;&amp; prices.length &gt; 1)&#123; int preBuy = Integer.MIN_VALUE ; int preSell = 0; int buy = Integer.MIN_VALUE; int sell = 0 ; for (int p : prices)&#123; //第1次买 preBuy = Math.max(preBuy, -p); preSell = Math.max(preSell, preBuy + p); buy = Math.max(buy, preSell - p); sell = Math.max(sell, buy + p ); &#125; return sell ; &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机 II]]></title>
    <url>%2F2019%2F01%2F23%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%2F</url>
    <content type="text"><![CDATA[1 算法描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2 解法12345678public int maxProfit(int[] prices) &#123; int maxprofit = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) maxprofit += prices[i] - prices[i - 1]; &#125; return maxprofit;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机I]]></title>
    <url>%2F2019%2F01%2F23%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAI%2F</url>
    <content type="text"><![CDATA[1 算法描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 2 Solution2.1 暴力算法时间复杂度：O(n^2)12345678910111213public int maxProfit(int[] prices) &#123; int maxProfit = 0 ; if (prices != null)&#123; for (int i = 0 ; i &lt; prices.length ; i ++)&#123; for (int j = i + 1 ; j &lt; prices.length ; j++) &#123; if (prices[j] &gt; prices[i])&#123; maxProfit = Math.max(maxProfit,(prices[j] - prices[i])); &#125; &#125; &#125; &#125; return maxProfit ;&#125; 2.2 动态规划前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}时间复杂度O(n) 123456789101112131415161718192021/** * 动态规划 * 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125; */public int maxProfit(int[] prices) &#123; if (prices.length &lt; 2) return 0; else if (prices.length == 2) return Math.max(0,prices[1]-prices[0]); else&#123; int i = 1 ; int maxProfit = Math.max(0,prices[1]-prices[0]); int minPrice = Math.min(prices[0],prices[1]); while (i &lt; prices.length)&#123; maxProfit = Math.max( maxProfit , prices[i] - minPrice); minPrice = Math.min(minPrice,prices[i]); i++; &#125; return maxProfit; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python制作微信好友照片墙]]></title>
    <url>%2F2018%2F12%2F24%2Fpython%E5%88%B6%E4%BD%9C%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%E7%85%A7%E7%89%87%E5%A2%99%2F</url>
    <content type="text"><![CDATA[安装itchat和pillow库12sudo pip install itchatsudo pip install pillow 代码如下wechat_head_img.py1234567891011121314151617181920212223242526272829303132333435363738394041424344import itchatimport mathimport osfrom PIL import Imageitchat.auto_login(hotReload=True)friends = itchat.get_friends(update=True)num = 0if not os.path.exists("headImg"): os.mkdir("headImg")for friend in friends: img = itchat.get_head_img(userName=friend["UserName"]) if len(img) == 0: print("skip %d,friend=%s" % (num,friend["NickName"]) ) continue print("%d,friend=%s" % (num,friend["NickName"])) fileImage = open('headImg' + "/" + str(num) + ".jpg",'web') fileImage.write(img) fileImage.close() num += 1all_image = os.listdir('headImg')print("There %d images" % len(all_image))each_size = int(math.sqrt(float(640*640)/len(all_image)))lines = int(640 / each_size)image = Image.new('RGBA',(640,640))x = 0y = 0for i in range(0,len(all_image)): imagePath = 'headImg'+"/"+str(i) + ".jpg" if not os.path.isfile(imagePath): continue img = Image.open(imagePath) img = img.resize((each_size,each_size),Image.ANTIALIAS) image.paste( img , (x*each_size,y*each_size) ) x += 1 if x == lines: x = 0 y += 1image = image.convert('RGB')image.save('headImg'+"/"+"all.jpg")itchat.send_image('headImg'+"/"+"all.jpg" , 'filehelper') 直接执行1234# 添加执行权限sudo chmod +x wechat_head_img.py# 执行python wechat_head_img.py]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现微信机器人AI智能回复]]></title>
    <url>%2F2018%2F12%2F24%2Fpython%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BAAI%E6%99%BA%E8%83%BD%E5%9B%9E%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[注册图灵机器人网站的账号链接：http://www.tuling123.com/你可以获取自己的图灵机器人apikey 代码123456789101112131415161718192021222324import itchatimport requestsdef get_response(_info): print(_info) api_url = 'http://www.tuling123.com/openapi/api' data = &#123; 'key': 'your_tuling_apikey', # 上一步注册的apikey 'info': _info, 'userid': 'robot', # 随意填 &#125; r = requests.post(api_url, data=data).json() print(r.get('text')) return r@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return r"[Bao]" + get_response(msg["Text"])["text"]if __name__ == '__main__': print("start") itchat.auto_login(hotReload=True) itchat.run()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac teminal ssh 免密码]]></title>
    <url>%2F2018%2F12%2F21%2FMac-teminal-ssh-%E5%85%8D%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、创建expect脚本 在/usr/local/bin目录下创建item2ssh.sh脚本 123456789101112131415#!/usr/bin/expectset timeout 15set port [lindex $argv 0]set username [lindex $argv 1]set host [lindex $argv 2]set passwd [lindex $argv 3]spawn ssh -p $port $username@$hostexpect &#123; "(yes/no)?" &#123;send "yes\n";exp_continue&#125; "password:" &#123;send "$passwd\n"&#125;&#125;interact 赋予可执行权限 12cd /usr/local/binsudo chmod +x item2ssh.sh 二、创建alias 创建alias在~目录下，创建.bash_alies文件，内容如下 1alias ssh2std='item2login.sh 22 username ip passwd' 修改.bash_profile添加以下几行 123if [ -f ~/.bash_aliases ]; then source ~/.bash_aliasesfi 5.source使之生效1source ~/.bash_profile 这样以后，直接敲ssd2std 就可以免密码ssh登录到std机器上了。 三、item2中使用在item2软件中，comand+, 弹出Preferences，然后可以添加Profiles,如下图所示]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC使用nginx分发80至8080端口]]></title>
    <url>%2F2018%2F12%2F21%2FMAC%E4%BD%BF%E7%94%A8nginx%E5%88%86%E5%8F%9180%E8%87%B38080%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、使用背景由于项目必须要启动80端口，但是mac系统中非root用户无法直接使用1024以下的端口 2、释放apache的80端口由于Mac OS是自带Apache服务的，它本身占用了80端口，首先你需要将Apache的监听端口改为其他端口或者将其直接卸载，我选用的是将其端口改为80111sudo vim /etc/apache2/httpd.conf Listen 8011 改动后，重启生效1sudo /usr/sbin/apachectl restart 到这里，你已经释放了80端口 3、使用Nginx分发80端口到8080端口 安装brew 见官网：https://brew.sh/index_zh-cn.html 使用Homebrew安装库 12brew search nginxbrew install nginx 安装好了后，修改配置 1sudo vim /usr/local/etc/nginx/nginx.conf 1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80; server_name localhost l.sogou.com; #charset koi8-r; #access_log logs/host.access.log main; location ~* ^/h5/&#123; proxy_pass http://127.0.0.1:8091; &#125; location ~* ^/weixin/&#123; proxy_pass http://127.0.0.1:8093; &#125; location ~* ^/api/&#123; proxy_pass http://127.0.0.1:8087; &#125; location / &#123; root html; index index.html index.htm; proxy_pass http://127.0.0.1:8080; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; server下的结点：listen：监听80端口server_name：转发到哪个地址proxy_pass：代理到哪个地址 Nginx开机启动 你需要了解的就是plist文件。plist就是property list format的意思，是苹果用来保存应用数据的格式，其实就是个xml。可以在/usr/local/opt/nginx 下找到nginx对应的plist文件，比如在作者电脑上是 homebrew.mxcl.nginx.plist 。 需要把这个文件复制到 /Library/LaunchDaemons 下，系统启动时启动。也可以复制到 /Library/LaunchAgents下，在用户登录时启动。接着执行launchctl load -w，如下： 123sudo cp /usr/local/opt/nginx/*.plist /Library/LaunchDaemonssudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 最后，重启你的机器，你会发现nginx在80端口启动了，试着通过http://localhost直接访问 修改配置 重启生效1234sudo vim /usr/local/etc/nginx/nginx.confcd /usr/local/opt/nginx/bin/sudo ./nginx -s reload]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[java字节码分析工具classpy]]></title>
    <url>%2F2018%2F12%2F05%2Fclasspy%2F</url>
    <content type="text"><![CDATA[字节码分析工具classpy这个开源工具的地址: https://github.com/zxh0/classpy classpy环境依赖下载地址上有说明，首先保证你的环境里配置了gradle git clone git@github.com:zxh0/classpy.git 下载工具 进入到classpy目录下执行命令3.1. 编译：gradle uberjar4.2. 启动：gradle run 经过以上两步就可以打开classpy界面，再打开一个class文件，如下所示]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>classpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install go]]></title>
    <url>%2F2018%2F11%2F06%2Finstall-go%2F</url>
    <content type="text"><![CDATA[Linux 下安装 下载 1wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz 解压到/usr/local目录下 1tar -C /usr/local -zxf go1.11.linux-amd64.tar.gz 加入环境变量 1export PATH=$PATH:/usr/local/go/bin 验证 1go version windows下安装1、下载https://studygolang.com/dl2、双击安装3、默认情况下.msi文件会安装在 c:\Go 目录下。你可以将 c:\Go\bin 目录添加到 PATH 环境变量中。添加后你需要重启命令窗口才能生效。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows cmdpython交互模式下cp65001异常]]></title>
    <url>%2F2018%2F11%2F01%2Fwindows%20cmd%20python%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E4%B8%8Bcp65001%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[python安装后进入命令行交互模式，输入任何代码都报 unknown encoding: cp65001异常 需要将编码(UTF-8)修改为 简体中文(GBK) 在CMD窗口执行 chcp 936]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 快捷键与 Eclipse 对比]]></title>
    <url>%2F2018%2F11%2F01%2FIntelliJ-IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IntelliJ IDEA快捷键: Eclipse vs IDEA快捷键:]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python写的一个简易的Http服务器]]></title>
    <url>%2F2018%2F11%2F01%2FhttpServer-by-python%2F</url>
    <content type="text"><![CDATA[昨天在看《Http权威指南》的时候，看到里面用Perl实现了一个最简单的Http的服务器。于是我参考着里面的逻辑写了一个python版本的。 创建服务器套接字（socket），把地址绑定到套接字上，并监听连接 服务器无限循环，接受客户端连接 客户端连接进来后，读取客户端发送的消息，并且打印Http请求报文 返回Http的响应报文 运行以下的python脚本后，使用浏览器访问http://localhost:8080/即可。 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env pythonfrom socket import *HOST = ''PORT = 8080BUFSIZE = 1024ADDR = (HOST,PORT)tcpSerSock = socket(AF_INET,SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)responseStr = '''HTTP/1.0 200 OKConnection:closeContent-type;text:plainHi there!'''while True: print 'waiting for connection ...' tcpCliSock , addr = tcpSerSock.accept() print '...connected from:',addr while True: data = tcpCliSock.recv(BUFSIZE) if not data: break print data tcpCliSock.send(responseStr) break tcpCliSock.close()tcpSerSock.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万圣节]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%B8%87%E5%9C%A3%E8%8A%82%2F</url>
    <content type="text"><![CDATA[万圣节今天是万圣节，11月1日，又是新的一个月的来临。 最近的一段时间过得很开心。 以后还是得继续更新日志才好。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式使用的特殊符号和字符]]></title>
    <url>%2F2018%2F10%2F30%2FRE-Metacharacter%2F</url>
    <content type="text"><![CDATA[正则表达式中最常见的符号和字符 记号 说明 正则表达式样例 literal 匹配字符串的值 foo re1&#124;rel2 匹配正则表达式re1或re2 foo&#124;bar . 匹配任何字符（换行符除外） b.b ^ 匹配字符串的开始 ^Dear $ 匹配字符串的结尾 /bin/*sh$ * 匹配前面出现的正则表达式零次或多次 [A-Za-z0-9]* + 匹配前面出现的正则表达式一次或多次 [a-z]+\.com ? 匹配前面出现的正则表达式零次或一次 goo? {N} 匹配前面出现的正则表达式N次 [0-9]{3} {M,N} 匹配重复出现M次到N次的正则表达式 [0-9]{5,9} […] 匹配字符组里出现的任意一个字符 [aeiou] [..x-y..] 匹配从字符x到y中任意一个字符 [0-9],[A-Za-z] [^…] 不匹配此字符组中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） [^aeiou],[^A-Za-z] (*&#124;+&#124;?&#124;{})? 用于上面出现的任何“非贪婪”，版本重复匹配次数符号 .*?[a-z] (…) 匹配封闭括号中正则表达式（RE），并保存为子组 （[0-9]{3}）?,f(oo&#124;u)bar \d 匹配任何数字，和[0-9]一样，（\D是\d的反义：任何非数字） data\d+.txt \w 匹配任何数字和字符，即A-Za-z0-9 [A-Za-z_]\w+ \s 匹配任何空白符，和[\n\t\r\v\f]相同，（\S是\s的反义） of\sthe \b 匹配单词边界（\B是\b的反义） \bThe\b \nn 匹配已保存的子组(参考上面的正则表达式符合:（…））) price:\16 \c 逐一匹配特殊字符c（即取消它的特殊含义，按字面匹配） .,\,* \A(\Z) 匹配字符换的起始（结束） \ADear]]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的BeanPostProcessor和BeanFactoryPostProcessor]]></title>
    <url>%2F2018%2F08%2F06%2FSpring%E4%B8%AD%E7%9A%84BeanPostProcessor%E5%92%8CBeanFactoryPostProcessor%2F</url>
    <content type="text"><![CDATA[BeanPostProcessor和BeanFactoryPostProcessor是Spring初始化Bean时对外暴露的2个接口，两个接口看起来很相似，但是作用和使用场景去不同。 参考博文：https://blog.csdn.net/caihaijiang/article/details/35552859 BeanFactoryPostProcessor接口的定义12345public interface BeanFactoryPostProcessor &#123; //实现该接口，可以在spring的bean创建之前，修改bean的定义属性。 void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;&#125; 实现该接口，可以在spring的bean创建之前，修改bean的定义属性。 也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改。例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。 可以同时配置多个BeanFactoryPostProcessor，并通过设置order属性来控制各个BeanFactoryPostProcessor的执行次序。 注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息 BeanPostProcessor简介BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。接口声明如下：1234567public interface BeanPostProcessor &#123; //bean初始化方法调用前被调用 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; //bean初始化方法调用后被调用 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; BeanPostProcessor接口有2个回调方法，当一个BeanPostProcessor的实现类注册到Spring IOC容器后，对于该Spring IOC 容器所创造的每一个bean实例的初始化方法（如afterPropertiesSet和自定义init-method方法）调用前，将会调用BeanPostProcessor中的postProcessBeforeInitialization方法；而在bean实例初始化方法调用完成后，则会调用BeanPostProcessor中的postProcessAfterInitialization方法。 整个调用过程简单示意如下： Spring IOC容器实例化Bean 调用BeanPostProcessor的postProcessBeforeInitialization方法 调用bean实例的初始化方法 调用BeanPostProcessor的postProcessAfterInitialization方法 可以看到，Spring容器通过BeanPostProcessor给了我们一个机会对Spring管理的bean进行再加工。比如：我们可以修改bean的属性，可以给bean生成一个动态代理实例等等。 一些Spring AOP的底层处理也是通过实现BeanPostProcessor来执行代理包装逻辑的。 BeanPostProcessor，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。这里说的初始化方法，指的是下面两种： bean实现了InitializingBean接口，对应的方法为afterPropertiesSet 在bean定义的时候，通过init-method设置的方法 注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。 spring中，有内置的一些BeanPostProcessor实现类，例如： org.springframework.context.annotation.CommonAnnotationBeanPostProcessor：支持@Resource注解的注入 org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor：支持@Required注解的注入 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：支持@Autowired注解的注入 org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor：支持@PersistenceUnit和@PersistenceContext注解的注入 org.springframework.context.support.ApplicationContextAwareProcessor：用来为bean注入ApplicationContext等容器对象 这些注解类的BeanPostProcessor，在spring配置文件中，可以通过这样的配置 &lt;context:component-scan base-package=”.“ /&gt; ，自动进行注册。 （spring通过ComponentScanBeanDefinitionParser类来解析该标签） 示例1.定义一个Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhj.postprocessor.bean;import org.springframework.beans.factory.InitializingBean;public class MyJavaBean implements InitializingBean &#123; private String desc; private String remark; public MyJavaBean() &#123; System.out.println("--------MyJavaBean的构造函数被执行啦--------"); &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; System.out.println("---------调用setDesc方法，desc="+desc); this.desc = desc; &#125; public String getRemark() &#123; return remark; &#125; public void setRemark(String remark) &#123; System.out.println("--------调用setRemark方法，remark="+remark); this.remark = remark; &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("--------调用afterPropertiesSet方法----------"); this.desc = "在初始化方法中修改之后的描述信息"; &#125; public void initMethod() &#123; System.out.println("--------调用initMethod方法------------"); &#125; @Override public String toString() &#123; return "MyJavaBean&#123;" + "desc='" + desc + '\'' + ", remark='" + remark + '\'' + '&#125;'; &#125;&#125; 2.自定义一个BeanFactoryPostProcessor 1234567891011121314151617181920212223242526272829303132333435package com.zhj.postprocessor;import org.springframework.beans.BeansException;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;/** * @author zhj on 2019-08-23. */public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(); System.out.println(); System.out.println("---------------调用MyBeanFactoryPostProcessor#postProcessBeanFactory---------------"); BeanDefinition bd = beanFactory.getBeanDefinition("myJavaBean"); MutablePropertyValues propertyValues = bd.getPropertyValues(); System.out.println("属性值：" + propertyValues.toString()); if (propertyValues.contains("remark")) &#123; propertyValues.addPropertyValue("remark", "把备注信息修改一下"); &#125; bd.setScope(BeanDefinition.SCOPE_PROTOTYPE); System.out.println("---------------end---------------"); System.out.println(); System.out.println(); &#125;&#125; 3.自定义一个BeanPostProcessor 1234567891011121314151617181920212223package com.zhj.postprocessor;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;/** * @author zhj on 2019-08-23. */public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeanPostProcessor，对象" + beanName + "调用初始化方法之前的数据： " + bean.toString()); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeanPostProcessor，对象" + beanName + "调用初始化方法之后的数据：" + bean.toString()); return bean; &#125;&#125; 4.Spring 配置文件 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"&gt; &lt;bean id="myJavaBean" class="com.zhj.postprocessor.bean.MyJavaBean" init-method="initMethod"&gt; &lt;property name="desc" value="原始的描述信息" /&gt; &lt;property name="remark" value="原始的备注信息" /&gt; &lt;/bean&gt; &lt;bean id="myBeanFactoryPostProcessor" class="com.zhj.postprocessor.MyBeanFactoryPostProcessor"/&gt; &lt;bean id="myBeanPostProcessor" class="com.zhj.postprocessor.MyBeanPostProcessor"/&gt;&lt;/beans&gt; 5.测试类 1234567891011121314151617181920212223package com.zhj.postprocessor;import com.zhj.postprocessor.bean.MyJavaBean;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author zhj on 2019-08-23. */public class PostProcessorTest &#123; @Test public void test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-processor.xml"); MyJavaBean bean = (MyJavaBean) context.getBean("myJavaBean"); System.out.println("-------------------下面输出结果----------------"); System.out.println("描述：" + bean.getDesc()); System.out.println("备注：" + bean.getRemark()); &#125;&#125; 6.执行结果 1234567891011121314151617---------------调用MyBeanFactoryPostProcessor#postProcessBeanFactory---------------属性值：PropertyValues: length=2; bean property 'desc'; bean property 'remark'---------------end-----------------------MyJavaBean的构造函数被执行啦-----------------调用setDesc方法，desc=原始的描述信息--------调用setRemark方法，remark=把备注信息修改一下BeanPostProcessor，对象myJavaBean调用初始化方法之前的数据： MyJavaBean&#123;desc='原始的描述信息', remark='把备注信息修改一下'&#125;--------调用afterPropertiesSet方法------------------调用initMethod方法------------BeanPostProcessor，对象myJavaBean调用初始化方法之后的数据：MyJavaBean&#123;desc='在初始化方法中修改之后的描述信息', remark='把备注信息修改一下'&#125;-------------------下面输出结果----------------描述：在初始化方法中修改之后的描述信息备注：把备注信息修改一下Process finished with exit code 0 从上面的结果可以看出，BeanFactoryPostProcessor在bean实例化之前执行，之后实例化bean（调用构造函数，并调用set方法注入属性值），然后在调用两个初始化方法前后，执行了BeanPostProcessor。初始化方法的执行顺序是，先执行afterPropertiesSet，再执行init-method。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring源码分析1-环境搭建]]></title>
    <url>%2F2018%2F08%2F01%2FSpring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring的源码在Github上，基于Gradle的构建来构建项目。所以要构建Spring源码首先要安装Github以及Gradle。github的安装不再赘述。 一.安装gradleGradle是一个基于Groovy的构建工具，它使用Groovy来编写构建脚本，支持依赖管理和多项目构建，类似于maven。 下载地址为：http://gradle.org/downloads windows下安装gradle下载后解压到指定目录，我放在了C:\Program Files\gradle-1.6 然后配置环境变量 根据对应目录创建GRADLE_HOME系统变量 将系统变量加入到path中 测试，打开命令窗口输入gradle -version,如果安装成功会出现Gradle对应的版本信息。 Mac下brew安装Gradle1.打开终端，使用brew install gradle完成安装 1$ brew info gradle 输出： 12345...省略==&gt; Downloading https://services.gradle.org/distributions/gradle-5.6-all.zip==&gt; Downloading from https://downloads.gradle-dn.com/distributions/gradle-5.6-all.zip######################################################################## 100.0%🍺 /usr/local/Cellar/gradle/5.6: 14,317 files, 245.0MB, built in 45 seconds 2.安装成功，默认的安装位置为：/usr/local/Cellar/gradle/5.6 3.验证是否安装成功，gradle -v,打印下面信息说明安装成功 1234567891011121314$ gradle -v------------------------------------------------------------Gradle 5.6------------------------------------------------------------Build time: 2019-08-14 21:05:25 UTCRevision: f0b9d60906c7b8c42cd6c61a39ae7b74767bb012Kotlin: 1.3.41Groovy: 2.5.4Ant: Apache Ant(TM) version 1.9.14 compiled on March 12 2019JVM: 1.8.0_191 (Oracle Corporation 25.191-b12)OS: Mac OS X 10.14.6 x86_64 二.下载Spring例如要将下载的源码存储到g:\spring下，进入这个目录，输入一下命令1$ git clone git@github.com:spring-projects/spring-framework.git spring-framework 等待一段时间后，完成下载。 进入这个目录，会看到已经存在了相应的源码信息12$ cd spring-framework/$ ll 三.构建spring并导入IDEA当前的源码并不可以直接导入到IDEA中，我们还需要将源码转换为IDEA可以读取的形式。 参考：https://github.com/spring-projects/spring-framework/blob/master/import-into-idea.md 步骤：1.Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava1$ ./gradlew :spring-oxm:compileTestJava 输出： 12345678910111213141516171819202122232425262728293031323334Downloading https://services.gradle.org/distributions/gradle-5.6-bin.zip.........................................................................................Welcome to Gradle 5.6!Here are the highlights of this release: - Incremental Groovy compilation - Groovy compile avoidance - Test fixtures for Java projects - Manage plugin versions via settings scriptFor more details see https://docs.gradle.org/5.6/release-notes.htmlStarting a Gradle Daemon (subsequent builds will be faster)&gt; Task :spring-core:compileTestJava注: 某些输入文件使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。&gt; Task :spring-beans:compileTestJava注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。&gt; Task :spring-context:compileTestJava注: 某些输入文件使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。&gt; Task :spring-oxm:genJaxb[ant:javac] : warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable buildsBUILD SUCCESSFUL in 4m 50s49 actionable tasks: 49 executed 2.导入IntelliJ步骤： (File -&gt; New -&gt; Project from Existing Sources -&gt; 打开项目根目录 -&gt; 选择 build.gradle) 3编译相关模块1.因为其他项目需要依赖spring-core和spring-oxm，所以我们导入后需要先编译这两个 2.执行完了后，接着编译spring-context，spring-bean,同样的方法 3.最后编译spring-aspects和spring-aop 4.CoroutinesUtils类 找不到的处理在spring-core项目的kotlin-coroutines的build目录下找到kotlin-coroutines-5.2.0.BUILD-SNAPSHOT.jar.再引入spring-core项目中即可。 5.完成到了这里，spring的源码基本编译完成，然后就可以学习、调试、修改了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pushy进行APNs消息推送]]></title>
    <url>%2F2018%2F07%2F25%2F%E4%BD%BF%E7%94%A8pushy%E8%BF%9B%E8%A1%8CAPNs%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[之前做了一个iOS消息推送的平台，主要是通过调用苹果提供的APNs接口进行消息的推送。最后采用了Pushy框架来进行推送。 pushy简介Pushy是用于发送APN（iOS、MacOS和Safari）推送通知的Java库，由Turo工程师编写和维护。 可以在github上获取源码和介绍：https://github.com/relayrides/pushy 官方文档：https://github.com/relayrides/pushy/wiki 使用pushy首先引入jar123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.turo&lt;/groupId&gt; &lt;artifactId&gt;pushy&lt;/artifactId&gt; &lt;version&gt;0.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.turo&lt;/groupId&gt; &lt;artifactId&gt;pushy-dropwizard-metrics-listener&lt;/artifactId&gt; &lt;version&gt;0.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt; &lt;artifactId&gt;metrics-servlets&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 建立连接下面这段代码主要用户建立服务器与苹果服务器之间的链接，当我们每次执行推送消息的时候，会去检查这个链接是不是还存在，如果存在就直接使用，否则执行下面的代码建立链接。与苹果的服务器的链接长时间没有数据发送过去的话，苹果服务器会主动将它断掉。 同时也可以通过setApnsServer函数来指定是开发环境还是生产环境。 是基于Netty的，通过ApnsClientBuilder我们可以根据需要来修改ApnsClient的连接数和EventLoopGroups的线程数setConcurrentConnections：设置服务器与苹果服务器建立几个链接通道，这里是建立4个，非越多越好setEventLoopGroup：建立几个线程来处理，这里设置了4个。相当于16个线程同时处理关于连接数和EventLoopGroup线程数官不要配置EventLoopGroups的线程数超过APNs连接数。 setMetricsListener：可以设置监听器，来监听发送消息的结果setClientCredentials：证书和密码。 123456789101112131415if (apnsClient == null) &#123; try &#123; EventLoopGroup eventLoopGroup = new NioEventLoopGroup(4); String apnsServer = mode.equals("sandbox")?ApnsClientBuilder.DEVELOPMENT_APNS_HOST:ApnsClientBuilder.PRODUCTION_APNS_HOST; apnsClient = new ApnsClientBuilder().setApnsServer(apnsServer) .setClientCredentials( new FileInputStream(p12_path), password ) .setConcurrentConnections(4) .setEventLoopGroup(eventLoopGroup) .setMetricsListener( metricsListener ) .build(); &#125; catch (Exception e) &#123; System.err.println(_.f("[%s][ERROR]ios get pushy apns client failed!",format.print(System.currentTimeMillis()))); e.printStackTrace(); &#125;&#125; 发送推送关于消息的推送，注意一定要使用异步操作，Pushy发送消息会返回一个Netty Future对象，通过它可以拿到消息发送的情况。 APNs服务器可以保证同时发送1500条消息，当超过这个限制时，Pushy会缓存消息，所以我们不必担心异步操作发送的消息过多（当我们的消息非常多，达到上亿时，我们也得做一些控制，避免缓存过大，内存不足，Pushy给出了使用Semaphore的解决方法）。1234567891011121314151617181920212223final Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; future = apnsClient.sendNotification(pushNotification); future.addListener(new PushNotificationResponseListener&lt;SimpleApnsPushNotification&gt;() &#123; @Override public void operationComplete(final PushNotificationFuture&lt;SimpleApnsPushNotification, PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; future) throws Exception &#123; if (future.isSuccess()) &#123; final PushNotificationResponse&lt;SimpleApnsPushNotification&gt; pushNotificationResponse = future.getNow(); if (pushNotificationResponse.isAccepted()) &#123; successCnt.incrementAndGet(); &#125; else &#123; Date invalidTime = pushNotificationResponse.getTokenInvalidationTimestamp(); if (invalidTime != null) &#123; System.out.println(_.f("[%s][ERROR]Notification deviceToken="+token+" rejected by the APNs gateway:" + pushNotificationResponse.getRejectionReason()+"\t...and the token is invalid as of " + pushNotificationResponse.getTokenInvalidationTimestamp(),format.print(System.currentTimeMillis()))); &#125;else&#123; System.out.println(_.f("[%s][ERROR]Notification deviceToken="+token+" rejected by the APNs gateway:" + pushNotificationResponse.getRejectionReason(),format.print(System.currentTimeMillis()))); &#125; &#125; &#125;else &#123; System.out.println(_.f("[%s][ERROR]send notification device token="+token+" is failed:" + future.cause().getMessage(),format.print(System.currentTimeMillis()))); &#125; latch.countDown(); semaphore.release(); &#125; &#125;); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.util.concurrent.Future;import java.io.FileInputStream;import java.util.Date;import java.util.List;import java.util.Map;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicLong;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import com.alibaba.fastjson.JSONObject;import com.turo.pushy.apns.ApnsClient;import com.turo.pushy.apns.ApnsClientBuilder;import com.turo.pushy.apns.PushNotificationResponse;import com.turo.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener;import com.turo.pushy.apns.util.ApnsPayloadBuilder;import com.turo.pushy.apns.util.SimpleApnsPushNotification;import com.turo.pushy.apns.util.TokenUtil;import com.turo.pushy.apns.util.concurrent.PushNotificationFuture;import com.turo.pushy.apns.util.concurrent.PushNotificationResponseListener;public class IOSPushClient &#123; private static ApnsClient apnsClient = null; //APNs服务器可以保证同时发送1500条消息，当超过这个限制时，Pushy会缓存消息，所以我们不必担心异步操作发送的消息过多 //通过Semaphore来进行流控，防止缓存过大，内存不足 private static final Semaphore semaphore = new Semaphore(6000); public static final DropwizardApnsClientMetricsListener metricsListener = new DropwizardApnsClientMetricsListener(); static final DateTimeFormatter format = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss.SSS"); public void push(String mode,String p12_path ,String password, final List&lt;String&gt; deviceTokens, String alertTitle , String alertBody,int badgeNumber,Map&lt;String,String&gt; extraMap) &#123; long startTime = System.currentTimeMillis(); if (apnsClient == null) &#123; try &#123; EventLoopGroup eventLoopGroup = new NioEventLoopGroup(4); String apnsServer = mode.equals("sandbox")?ApnsClientBuilder.DEVELOPMENT_APNS_HOST:ApnsClientBuilder.PRODUCTION_APNS_HOST; apnsClient = new ApnsClientBuilder().setApnsServer(apnsServer) .setClientCredentials( new FileInputStream(p12_path), password ) .setConcurrentConnections(4) .setEventLoopGroup(eventLoopGroup) .setMetricsListener( metricsListener ) .build(); &#125; catch (Exception e) &#123; System.err.println(_.f("[%s][ERROR]ios get pushy apns client failed!",format.print(System.currentTimeMillis()))); e.printStackTrace(); &#125; &#125; long total = deviceTokens.size(); //通过CountDownLatch来标记消息是否发送完成 final CountDownLatch latch = new CountDownLatch(deviceTokens.size()); final AtomicLong successCnt = new AtomicLong(0); long startPushTime = System.currentTimeMillis(); for (String deviceToken : deviceTokens) &#123; ApnsPayloadBuilder payloadBuilder = new ApnsPayloadBuilder(); payloadBuilder.setAlertBody(alertBody); payloadBuilder.setAlertTitle(alertTitle); payloadBuilder.setBadgeNumber(badgeNumber); payloadBuilder.setSoundFileName("default"); //自定义键值对，其中value是Object，可以支持多层的json字串，这个根据业务需求而定 if(extraMap != null &amp;&amp; extraMap.size() &gt; 0 )&#123; for(String key : extraMap.keySet())&#123; String value = extraMap.get(key); if("extraData".equals(key))&#123; payloadBuilder.addCustomProperty(key,JSONObject.parse(value)); &#125;else&#123; payloadBuilder.addCustomProperty(key,value); &#125; &#125; &#125; String payload = payloadBuilder.buildWithDefaultMaximumLength(); //最大4k final String token = TokenUtil.sanitizeTokenString(deviceToken); SimpleApnsPushNotification pushNotification = new SimpleApnsPushNotification(token, "com.sogou.sogoureader" , payload); try &#123; semaphore.acquire(); &#125; catch (InterruptedException e)&#123; System.out.println(_.f("[%s][ERROR]ios push get semaphore failed, deviceToken:"+deviceToken,format.print(System.currentTimeMillis()))); e.printStackTrace(); &#125; final Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; future = apnsClient.sendNotification(pushNotification); future.addListener(new PushNotificationResponseListener&lt;SimpleApnsPushNotification&gt;() &#123; @Override public void operationComplete(final PushNotificationFuture&lt;SimpleApnsPushNotification, PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; future) throws Exception &#123; if (future.isSuccess()) &#123; final PushNotificationResponse&lt;SimpleApnsPushNotification&gt; pushNotificationResponse = future.getNow(); if (pushNotificationResponse.isAccepted()) &#123; successCnt.incrementAndGet(); &#125; else &#123; Date invalidTime = pushNotificationResponse.getTokenInvalidationTimestamp(); if (invalidTime != null) &#123; System.out.println("[ERROR]Notification deviceToken="+token+" rejected by the APNs gateway."); &#125;else&#123; System.out.println("Notification deviceToken="+token+" rejected by the APNs gateway"); &#125; &#125; &#125;else &#123; System.out.println("[ERROR]send notification device token="+token+" is failed:"); &#125; latch.countDown(); semaphore.release(); &#125; &#125;); &#125; try &#123; latch.await(20, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; System.out.println("[ERROR]ios push latch await failed!"); e.printStackTrace(); &#125; long endPushTime = System.currentTimeMillis(); System.out.println("IOSPushClient pushMessage success. [total push=" + total + "][succ push=" + (successCnt.get()) + "], totalcost= " + (endPushTime - startTime) + ", pushCost=" + (endPushTime - startPushTime) , format.print(System.currentTimeMillis()))); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>pushy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka 生产者和消费者]]></title>
    <url>%2F2018%2F07%2F25%2Fkafka-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[maven配置12345678910 &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;0.11.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.11.0.2&lt;/version&gt;&lt;/dependency&gt; KafkaProducerKafkaProducer初始化1234567891011121314151617public static KafkaProducer&lt;String, String&gt; kafkaProducer = null ;static &#123; try &#123; Properties props = new Properties(); props.put("bootstrap.servers",QueueConstants.BROKER_LIST); props.put("acks", "all"); props.put("retries", 1); props.put("batch.size", 16384); props.put("linger.ms", 1); props.put("buffer.memory", 33554432); props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); kafkaProducer = new KafkaProducer&lt;String,String&gt;(props); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; KafkaProducer send消息(异步方式)123456QueueConstants.kafkaProducer.send(new ProducerRecord&lt;String, String&gt;(topic, msg), new Callback() &#123; @Override public void onCompletion(RecordMetadata metadata, Exception exception) &#123; System.out.println("MessageProducer sended,metadata:"+metadata.toString()); &#125; &#125;); KafkaConsumer1234567891011private KafkaConsumer&lt;String, String&gt; createConsumer()&#123; Properties props = new Properties(); props.put("bootstrap.servers", QueueConstants.BROKER_LIST ); props.put("group.id", groupId); //必须要使用别的组名称， 如果生产者和消费者都在同一组，则不能访问同一组内的topic数据 props.put("enable.auto.commit", false); props.put("auto.commit.interval.ms", "1000");//自动确认offset的时间间隔 props.put("session.timeout.ms", "30000"); props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); return new KafkaConsumer&lt;&gt;(props); &#125; 消费消息1234567891011121314151617181920212223242526272829303132333435@SuppressWarnings("unchecked")@Override public void run() &#123; KafkaConsumer&lt;String, String&gt; consumer =createConsumer(); consumer.subscribe(Arrays.asList(topic)); try &#123; while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; consumer.commitAsync(new OffsetCommitCallback() &#123; @Override public void onComplete(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception) &#123; if (null == exception) &#123; //表示偏移量成功提交 System.out.println("IosPushySender commit succ"); &#125; else &#123; //表示提交偏移量发生了异常，根据业务进行相关处理 System.out.println("IosPushySender commit exception ,"+exception.toString()); &#125; &#125; &#125;); if(_.nonEmpty(record.value()))&#123; String message = new String(record.value().getBytes(), "UTF-8"); //... //消费消息 &#125; &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; consumer.close(); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring在任意类中getBean]]></title>
    <url>%2F2018%2F07%2F25%2Fspring%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%B1%BB%E4%B8%ADgetBean%2F</url>
    <content type="text"><![CDATA[ApplicationContextAware接口ApplicationContextAware接口的bean在被初始化之后，可以在任意类中拿到容器中的bean 实现这个接口的代码：12345678910111213141516171819202122232425262728293031323334353637package web.utils;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class SpringContextUtil implements ApplicationContextAware &#123; private static ApplicationContext context = null; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; context = applicationContext; &#125; public static ApplicationContext getApplicationContext() &#123; assertApplicationContext(); return context; &#125; @SuppressWarnings("unchecked") public static &lt;T&gt; T getBean(String beanName) &#123; assertApplicationContext(); return (T) context.getBean(beanName); &#125; public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) &#123; assertApplicationContext(); return context.getBean(requiredType); &#125; private static void assertApplicationContext() &#123; if (SpringContextUtil.context == null) &#123; throw new RuntimeException("applicaitonContext属性为null,请检查是否注入了SpringContextUtil!"); &#125; &#125;&#125; 在application.xml文件中定义对应的bean,或者通过注解@Component标注1&lt;bean class="web.utils.SpringContextUtil" lazy-init="false" &gt;&lt;/bean&gt; 配置web.xml123456789&lt;!-- 全局spring定义 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-mvc.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- ContextLoaderListener载入 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 使用在任意类中，可以直接拿到bean了1LoggerDao loggerDao = (LoggerDao) SpringContextUtil.getBean( LoggerDao.class);]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb replica sets副本集集群搭建]]></title>
    <url>%2F2018%2F07%2F13%2Fmongodb-replica-sets%2F</url>
    <content type="text"><![CDATA[一、replica sets简介一个副本集是一组包含相同数据集的mongodb实例组成的集群系统。有一个primary节点，其他的节点为secondary节点。和主从复制的原理一样，副本集也是通过读取oplog来进行数据传输，oplog是一固定大小的表，创建的时候需要指定其大小，当oplog满的时候会删除旧的数据，所以设置其大小非常重要，如果oplog被primary节点覆盖而尚未被sencondary节点读取同步的话就要重新resync。一般的replica sets集群的架构如下图所示：一主一备和一个仲裁（Arbitry）节点，仲裁节点不存放数据。 同步方式采用异步同步的方式，成员节点每隔2s发送一次heartbeat（pings）。当主节点与其他成员节点通信超时10s后，一个sencondary节点将会被选举为primary节点。 二、环境搭建 在所有机器上安装mongodb，我安装在/usr/local/ 目录下。 创建数据目录，/search/odin/data 在每台机器的mongodb的bin目录下创建配置文件mongod.conf,内如如下 12345dbpath=/search/odin/mongodb/datalogpath=/search/odin/mongodb/logfork=trueport=27017oplogSize=2048 启动mongodb 1./mongod -f mongod.conf 三、创建replica sets下面是搭建一个一主一从一仲裁 三节点replica sets的具体步骤 添加replSet参数123456789dbpath=/search/odin/mongodb/datalogpath=/search/odin/mongodb/logfork=trueport=27017replSet=rs0 然后启动三台服务器。 初始化副本集连接其中一个节点，初始化命令只能执行一次。可以先配置一个配置文件,然后使用rs.initiate(rsconf)来初始化,例如:123456789101112rsconf = &#123; _id: "rs0", members: [ &#123; _id: 0, host: "10.143.40.142:27017" &#125; ]&#125;rs.initiate(rsconf) 检查初始化配置文件1rs.conf() 添加secondary和arbitry节点123456789# 添加一个节点rs.add("10.143.41.140:27017")#添加一个arbitary节点rs.add("10.143.55.191:27017"，true)#查看副本集的当前状态：rs.status() rs.remove删除一个结点12#rs.remove()就一个参数hostname:rs.remove("mongodb3:27017") rs.addArb添加投票节点rs.addArb()同样可以添加投票节点,也只有一个参数为hostname:1rs.remove("mongodb3:27017") 查看状态1db.printSlaveReplicationInfo(); 查看数据信息rs.isMaster()，是否为主节点 rs.secondary():是否为从节点 rs.primary():指出当前副本集中的主节点位于哪个进程 rs.config():查看详细的配置信息]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>replica sets</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾收集器和内存分配策略]]></title>
    <url>%2F2018%2F07%2F04%2FJVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述 程序计数器、虚拟机栈、本地方法栈 三个区域随线程而生，随线程而灭 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知 方法区和堆中的内存使用是不确定的，垃圾收集器所关注的就是这部分内存。 栈帧（Stack Frame） 是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟栈数据区的组成元素。每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。一个线程中方法调用可能很长，很多方法都处于执行状态。对于执行引擎来说，只有处于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与之相关联的方法称为当前方法（Current Method）。概念模型上，典型的栈帧主要由 局部变量表（Local Stack Frame）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、返回地址（Return Address）组成。 对象存活判定算法引用计数算法给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器减1。 但是主流的Java虚拟机里并没有选用这种方法来管理内存，因为它很难解决对象之间相互循环引用的问题。 可达性分析算法主流的实现中，是通过可达性分析（Reachability Analysis）来判断对象是否存活。 基本思路：通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径成为引用链（Reference Chain）。当一个对象到GC Roots没有任务引用链相连时，证明此对象不可用，就会被判定为可回收对象。 Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 引用JDK1.2之后，引用分为4种，引用强度以此减弱： 强引用（Strong Reference）:只要强引用在，垃圾收集器永远不会回收掉被引用的对象 软引用（Soft Reference）：系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收 弱引用（Weak Reference）:被弱引用关联的对象只能生存到下一次垃圾收集发生之前 虚引用（Phantom Reference）：唯一目的是能在这个对象被收集器回收时收到一个系统通知。 对象死亡的步骤可达性分析算法中不可达的对象，会至少经历两次标记的过程，才会死亡： 可达性分析后发现没有与GC Roots相连接的引用链，那么会被第一次标记并进行一次筛选 帅选：如果对象没有覆盖finalize()方法或finalize()已经被虚拟机调用过，虚拟机会将不会再执行finalize()方法 如果这个对象判断为有必要执行finalize()，那么这个对象会被放置在一个F-Queue队列中，稍后会由一个Finalizer线程去执行finalize()。finalize()方法是对象逃逸死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记。 第二次标记时它被移除出“即将回收”的集合，这时候还没逃脱，就真的被回收了。 回收方法区方法区在HotSpot虚拟机中的永久代，永久代的垃圾收集主要回收两部分内容： 废弃常量 无用的类 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 新生代、老年代、永久代新生代(堆中)主要是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区、Survivor（ServivorFrom、ServivorTo）三个区(默认比例是8:1:1),采用复制算法。 老年代（堆中）是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）老年代采用的是标记-清除或者标记-整理算法，这两个算法主要看虚拟机采用的哪个收集器，两种算法的区别是：标记-清除可能会产生大量连续的内存碎片。在老年代中的GC则为Major GC。Major GC和Full GC会造成stop-the-world。 永久代JVM的方法区，也被称为永久代。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收 垃圾收集算法标记-清除算法（Mark-Sweep）分为“标记”和“清除”两个阶段。 不足：效率问题，标记和清除的效率都不高会产生大量的内存碎片 复制算法（Copying）将内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况。 现在商业虚拟机都采用这种算法来回收新生代。不过是把内存分为一块较大的 Eden空间和两块较小的Survivor空间。 每次使用Eden和其中一块Survivor空间，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Surv空间上，最后清理掉Eden和刚才用过的Survivor空间。 如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。 标记-整理算法标记过程仍然和“标记-清除”算法一样，但是后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法根据对象存活周期的不同将内存分为几块：一般把Java堆分为新生代和老年代。新生代中，每次垃圾收集时，都会发现有大量对象死去，只有少量存活，那就选用复制算法。老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或”标记-整理”算法来进行回收。 HotSpot的算法实现枚举根节点GC进行的时候，需要进行可达性分析，枚举根节点，可达性分析需要Stop The World。可以作为GC Roots的节点主要在全局行的引用与执行上下文中。当执行系统停顿下来后，虚拟机并不需要一个不漏地检查完所有执行上下文和全局的引用位置。HotSpot的实现中，使用一组称为OopMap的数据结构来直接得知哪些地方存着对象的引用。 安全点在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举。HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录下这些信息，这些位置称为安全点（Safepoint）。 程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 安全区域安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。 线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程）。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑二叉查找树]]></title>
    <url>%2F2018%2F07%2F03%2FRedBlackBST%2F</url>
    <content type="text"><![CDATA[2-3查找树定义：一棵2-3查找树或为一棵空树，或由以下结点组成： 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点，还有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 我们将指向一棵空树的链接称为空链接。 红黑二叉查找树基本思想：我们将树中的链接分为两种类型： 红链接：将两个2-结点连接起来构成一个3-结点 黑链接：则是2-3树中的普通链接 我们将3-结点表示为由一条左斜的红色链接相连的2个结点 红黑二叉查找树既是二叉查找树，又是2-3查找树，所以我们可以将两个算法的有点结合起来，二叉查找树简洁高效的查找方法和2-3树中高效的平衡插入算法。 实现颜色表示为方便起见，每个结点都只会有一条指向自己的链接（从它的父节点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量中，如果指向它的链接是红色的，那么该变量为true，黑色为false，我们约定空链接为黑色。 颜色表示的代码实现12345678910111213141516171819202122232425262728private static final boolean RED = true;private static final boolean BLACK = false;private Node root ;private boolean isRed(Node x )&#123; if (x == null) &#123; return false ; &#125; return x.color == RED;&#125;private class Node&#123; Key key ; Value val; Node left , right ; int N ; boolean color; public Node(Key key , Value val ; int N , boolean color)&#123; this.key = key; this.val = val ; this.N = N; this.color = color; &#125;&#125; 旋转与颜色转换左旋转假设我们有一条红色的右链接，需要被转化为左链接，这个操作叫做 左旋转。只是将用两个键中较小者作为根结点变为将较大者作为根结点。 12345678910private Node rotateLeft(Node h)&#123; assert isRed(h.right); Node x = h.right; x.left = h ; x.color = h.color; h.color = RED ; x.N = h.N; h.N = size( h.left ) + size( h.right ) + 1 ; return x ;&#125; 右旋转原理和左旋转一样 12345678910private Node rotateRight(Node h)&#123; assert isRed(h.left); Node x = h.left; x.right = h ; x.color = h.color; h.color = RED ; x.N = h.N; h.N = size( h.left ) + size( h.right ) + 1 ; return x ;&#125; 颜色转换当一个结点有两个红色结点的时候，除了需要将子结点的颜色由红变黑，还需要将父节点的颜色由黑变红 12345678private void flipColors(Node h)&#123; assert !isRed(h); assert isRed(h.left); assert isRed(h.right); h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125; 根结点总是黑色颜色转换会使根结点变成红色，这时候我们将根结点设为黑色。注意，每当根结点由红变黑时，树的黑链接高度就会加1 插入新键插入新键总是用红色链接将新节点和它的父结点相连，然后需要的时候，再进行旋转，颜色变换操作。 向单个2-结点中插入新键（这个2-结点是根结点） 如果新插入的结点的键小于老键，直接新增一个红色的结点即可 如果新插入的结点的键大于老键，新增的红色结点会产生一条红色的右链接，执行左旋转即可。 树底部的2-结点插入新键同向单个2-结点中插入新键 向一棵双键树（即一个3-结点）中插入新键 新键小于树中的2个键 两者之间 新键大于树中的两个键 过程如图所示： 插入实现总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作即可。 如果右子结点是红色的，而左子结点是黑色的，进行左旋转 如果左子结点是红色的，且它的左子结点也是红色的，进行右旋转 如果左右子结点都是红色的，进行颜色转换 12345678910111213141516171819202122232425262728293031323334public void put(Key key , Value val)&#123; //查找key，找到则更新其值，否则为它新建一个结点。 root = put(root，key，val); root.color = BLACK; //根结点总是黑色&#125;private Node put(Node h , Key key , Value val)&#123; if (h == null) &#123; //标准的插入操作，和父节点用红链接相连 return new Node(key , val , 1, RED); &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 ) &#123; h.left = put(h.left,key,val); &#125;else if (cmp &gt; 0 ) &#123; h.right = put(h.right , key ,val ); &#125;else&#123; h.val = val ; &#125; //除了这三条if语句，红黑树中put()的递归实现和二叉查找树中的put()的实现完全相同 if (isRed(h.right) &amp;&amp; !isRed(h.left)) &#123; h = rotateLeft(h); &#125; if (isRed(h.left) &amp;&amp; isRed(h.left.left) ) &#123; h = rotateRight(h); &#125; if (isRed(h.left) &amp;&amp; isRed(h.right)) &#123; flipColors(h); &#125; h.N = size(h .left)+ size (h.right ) + 1 ; return h;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树 Binary Search Tree]]></title>
    <url>%2F2018%2F07%2F03%2FBinary-Search-Tree%2F</url>
    <content type="text"><![CDATA[定义一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关联的的值），且每个结点的键都大于其左子树的结点的键而小于右子树的结点的键。 基本实现结点我们嵌套定义了一个私有类来表示二叉查找树的一个结点，每个结点都含有一个键、一个值、一条左链接、一条右链接、和一个结点计数器 12345678910111213private class Node&#123; private Key key;//键 private Value val;//值 private Node left,right;//指向左右子树的链接 private int N ;//以该结点为根结点的子树中的结点总数 public Node(Key key , Value val , int N)&#123; this.key = key ; this.val = val ; this.N = N ; &#125;&#125; 私有方法size()会将空链接的值当做0；这样我们通过以下公式来计算结点x的N值size(x) = size(x.left) + size(x.right) + 1 ;1234567891011public int size()&#123; return size(root);&#125;private int size(Node x)&#123; if (x == null) &#123; return 0 ; &#125;else&#123; return x.N; &#125;&#125; 查找一般来说，在符号表（二叉查找树是一个符号表）中查找一个键，可能有两种结果：如果含有该键的结点存在于表中，我们的查找命中，返回结点的值；否则未命中，返回null。 在二叉查找树中查找一个键的递归算法： 如果树是空的，则查找未命中 如果被查找的键和根结点的键相等，查找命中 否则我们就递归地在适当的子树中查找 12345678910111213141516171819public Value get(Key key)&#123; return get(root,key);&#125;private Value get(Node x , Key key)&#123; //在以x结点为根结点的子树中查找并返回key所对应的值 //如果找不到则返回null if (x == null) &#123; return null ; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 ) &#123; return get(x.left,key); &#125;else if (cmp &gt; 0 ) &#123; return get(x.right,key); &#125;else&#123; return x.val; &#125;&#125; 插入在二叉查找树中递归插入一个结点的算法： 如果树是空的，就安徽一个含有该键值对的新节点 如果被查找的键小于根结点的键，我们会继续在左子树中插入该键 否则在右子树中插入该键 12345678910111213141516171819public void put(Key key , Value val)&#123; put(root,key,val);&#125;private Node put(Node x , Key key,Value val)&#123; if (x == null) &#123; return new Node(Key,val,1); &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 ) &#123; x = put(x.left,key,val); &#125;else if (cmp &gt; 0 ) &#123; x = put(x.right,key,val); &#125;else&#123; x.val = val; &#125; x.N = size(x.left) + size(x.right) + 1 ; return x ;&#125; 有序性相关的方法二叉查找树可以保持键的有序性 最小键和最大键最小键： 如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点； 如果左链接非空，那么树中最小的键就是左子树中的最小键 最大键： 如果根结点的右链接为空，那么一棵二叉查找树中最大的键就是根结点； 如果右链接非空，那么树中最大的键就是右子树中的最大键 递归实现查找最小键、最大键：123456789101112131415161718192021public Key min()&#123; return min(root).key;&#125;private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left);&#125;public Key max()&#123; return max(root).key;&#125;private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right);&#125; 向上取整和向下取整向上取整： 如果给定的key小于二叉查找树的根结点的键，那么小于等于key的最大键floor(key)一定在根结点的左子树中 如果给定的键key大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于key的结点时，小于等于key的最大结点才会出现在右子树中，否则根结点就是小于等于key的最大键。 1234567891011121314151617181920212223242526public Key floor(Key key)&#123; Node x = floot(root,key); if (x == null) &#123; return null ; &#125; return x.key;&#125;public Node floor(Node x , key)&#123; if (x == null) &#123; return null ; &#125; int cmp = key.compareTo(x.key); if (cmp == 0 ) &#123; return x ; &#125; if (cmp &lt; 0 ) &#123; return floor(x.left,key); &#125; Node t = floor(x.right,key); if (t != null) &#123; //当根结点右子树中存在小于等于key的结点时 return t ; &#125;else&#123; return x ; &#125;&#125; 向下取整：12345678910111213141516171819202122public Key ceiling(Key key)&#123; Node x = ceiling(root,key); if (x == null ) return null; else return x.key;&#125;private Node ceiling(Node x ,Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0 ) return x; if (cmp &gt; 0 ) return ceiling(x.right,key); Node t = ceiling(x.left,key); if (t != null) return t ; else return x;&#125; 排名 select(int k)、rank(Key key)假设我们要找排名为k的键（即树中正好有k个小于它的键）： 如果左子树中的结点树t大于k，那么我们就递归地在左子树中查找排名为k的键 如果t=k,我们就返回根结点键（根结点就是排名k） 如果t&lt;k,我们递归地在右子树中查找排名为 (k-t-1)的键 123456789101112131415161718public Key select(k)&#123; return select(root,k).key;&#125;private Node select(Node x,int k)&#123; //返回排名为k的结点 if (x==null) &#123; return null; &#125; int t = size(x.left); if (t &gt; k) &#123; return select(x.left,k); &#125;else if (t &lt; k ) &#123; return select(x.right,k-t-1); &#125;else&#123; return x; &#125;&#125; 返回给定Key的排名： 如果给定的key和根结点的键相等，我们返回左子树的结点总数t； 如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）； 如果给定的键大于根结点，我们返回 t+1 + 它在右子树中的排名（递归计算）。 12345678910111213141516public int rank(Key key)&#123; return rank(root,key);&#125;private int rank(Node x , Key key)&#123; if (x == null ) &#123; return 0 ; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; return rank(x.left,key); &#125;else if ( cmp &gt; 0) &#123; return size(x.left) + 1 + rank(x.right,key); &#125;else&#123; return x ; &#125;&#125; 删除操作删除最大键和删除最小键删除最小键： 我们需要不断深入根结点的左子树，直到遇见一个空链接，然后将指向该结点的链接指向该结点的右子树 1234567891011public void deleteMin()&#123; deleteMin(root);&#125;private Node deleteMin(Node x )&#123; if (x.left == null ) &#123; return x.right; &#125; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1 ; return x ;&#125; 删除最大键： 不断深入根结点的右子树，直到遇见一个空链接，然后将指向该结点的链接指向该结点的左子树 1234567891011public void deleteMax()&#123; deleteMax(root);&#125;private Node deleteMax(Node x)&#123; if (x.right == null) &#123; return x.left; &#125; x.right = deleteMax(x.right); x.N = size(x.left) + size(x.right) + 1 ; return x ;&#125; 删除操作删除一个结点t：1、找到以这个结点t为根结点的子树的最小结点x=min(t),x替换该结点t2、x的左子树指向 被删结点t的左子树3、x的右子树指向 删除了最小结点的原来的t的右子树（deleteMin(t.right)） 123456789101112131415161718192021222324252627282930public void delete(Key key)&#123; root = delete(root,key);&#125;private Node delete(Node x , Key key)&#123; if (x == null) &#123; return null ; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 ) &#123; x.left = delete(x.left,key); &#125;else if (cmp &gt; 0 ) &#123; x.right = delete(x.right,key); &#125;else&#123; //找到这个结点t if (x.right == null ) &#123; return x.left ; &#125; if (x.left == null ) &#123; return x.right ; &#125; Node t = x ; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; x.N = size(x.left) + size(x.right) + 1 ; return x ; &#125;&#125; 中序遍历将二叉排序树中的所有结点的键按顺序打印出来12345678private void print(Node x)&#123; if (x == null) &#123; return ; &#125; print(x.left); System.out.println(x.key); print(x.right);&#125; 范围查找返回指定范围内的键的keys()方法将所有落在指定范围以内的键加入一个队列Queue，并跳过哪些不可能含有所查找键的子树1234567891011121314151617181920212223242526public Iterable&lt;Key&gt; keys()&#123; return keys(min(),max());&#125;public Iterable&lt;Key&gt; keys(Key lo , Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue;&#125;private void keys(Node x , Queue queue ,Key lo , Key hi )&#123; if (x == null) &#123; return ; &#125; int cmplo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); if (cmplo &lt; 0 ) &#123; keys(x.left,queue,lo , hi); &#125; if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0 ) &#123; queue.enqueue(x.key); &#125; if (cmphi &gt; 0 ) &#123; keys(x.right , queue,lo ,hi); &#125;&#125; 性能分析在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。 完整实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297package com.practice.algorithms;import edu.princeton.cs.algs4.StdOut;import edu.princeton.cs.algs4.StdRandom;public class BinarySearchTree&lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123; private Node root ; //二叉查找树的根节点 private class Node&#123; private Key key; private Value val; private Node left,right; private int N; public Node(Key key, Value val,int n) &#123; this.key = key; this.val = val; N = n; &#125; &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null)&#123; return 0 ; &#125;else&#123; return x.N; &#125; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node x , Key key)&#123; //在以x为根节点的子树中查找并返回key所对应的值 //如果找不到，则返回null if (x == null)&#123; return null; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 )&#123; return get(x.left,key); &#125;else if (cmp &gt; 0 )&#123; return get(x.right,key); &#125;else&#123; return x.val; &#125; &#125; public void put(Key key ,Value val)&#123; //查找可key，找到则更新它的值，否则为它创建一个新的节点 root = put(root,key,val); &#125; /** * 递归实现 */ private Node put(Node x , Key key , Value val)&#123; //如果key存在与以x为根节点的子树中，则更新它的值 //否则将以key和val为键值对的新节点插入到该子树中 if (x == null) &#123; return new Node(key, val, 1); &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0 )&#123; x.left = put(x.left,key,val); &#125;else if (cmp &gt; 0 )&#123; x.right = put(x.right,key,val); &#125;else&#123; x.val = val ; &#125; x.N = size(x.left) + size(x.right) + 1; return x; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; else return min(x.left); &#125; public Key max()&#123; return max(root).key; &#125; private Node max(Node x)&#123; if (x.right == null) return x; else return max(x.right); &#125; public Key floor(Key key)&#123; Node x = floor(root,key); if (x == null ) return null; else return x.key; &#125; private Node floor(Node x ,Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0 ) return x; if (cmp &lt; 0 ) return floor(x.left,key); Node t = floor(x.right,key); if (t != null) return t ; else return x; &#125; public Key ceiling(Key key)&#123; Node x = ceiling(root,key); if (x == null ) return null; else return x.key; &#125; private Node ceiling(Node x ,Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0 ) return x; if (cmp &gt; 0 ) return ceiling(x.right,key); Node t = ceiling(x.left,key); if (t != null) return t ; else return x; &#125; public Key select(int k)&#123; return select(root,k).key; &#125; /** * 以x为根节点，查找排名为k的节点 * 如果左子树中的结点树t大于k，继续递归地在左子树中查找排名为k的键 * 如果t=k，返回根节点中的键 * 如果t&lt;k。那么我们就递归地在右子树中查找排名为（k-t-1）的键 */ private Node select(Node x,int k)&#123; if (x == null) return null; int t = size(x.left); if ( t &gt; k ) &#123; return select(x.left, k); &#125;else if (t &lt; k )&#123; return select(x.right,k-t-1); &#125;else &#123; return x; &#125; &#125; public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node x,Key key)&#123; //返回以x为根节点的子树中小于x.key的键的数量 if (x== null ) return 0 ; int cmp = key.compareTo(x.key); if (cmp &lt; 0 )&#123; return rank(x.left,key); &#125;else if (cmp &gt; 0)&#123; return rank(x.right,key); &#125;else&#123; return size(x.left); &#125; &#125; /** * 不断深入根节点的左子树，直至遇见一个空链接 * 然后将指向该节点的链接指向该节点的右子树（只要在递归调用中返回它的右链接即可） */ public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x ; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; private Node deleteMax(Node x)&#123; if (x.right == null) return x.left; x.right = deleteMin(x.right); x.N = size(x.left) + size(x.right) + 1; return x ; &#125; public void delete(Key key)&#123; root = delete(root,key); &#125; private Node delete(Node x ,Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0 ) x.left = delete(x.left,key); else if (cmp &gt; 0) x.right = delete(x.right,key); else&#123; //找到了这个要删除的节点了 x if (x.right == null) return x.right; if (x.left == null ) return x.right; Node t = x ; x = min(t.right); x.right = deleteMin(t.right); //将x的右子树最小节点删除 x.left = t.left; &#125; x.N = size(x.left) + size(x.right) + 1; return x ; &#125; private void print(Node x)&#123; if ( x == null) return ; print(x.left); StdOut.println(x.key); print(x.right); &#125; public Iterable&lt;Key&gt; keys()&#123; return keys(min(),max()); &#125; public Iterable&lt;Key&gt; keys(Key lo , Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node x,Queue&lt;Key&gt; queue,Key lo , Key hi)&#123; if (x == null ) return ; int cmplo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); if (cmplo &lt; 0) keys(x.left,queue,lo,hi); if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0 )&#123; queue.enqueue(x.key); &#125; if (cmphi &gt; 0 ) keys(x.right,queue,lo,hi); &#125; public static void main(String[] args) &#123; BinarySearchTree&lt;String,Integer&gt; bst = new BinarySearchTree&lt;String,Integer&gt;(); for (int i = 0; i &lt; 1000000; i++) &#123; String key = StdRandom.uniform(0,1000)+""; int val = 0 ; if (bst.get(key)!=null)&#123; val = bst.get(key) + 1; &#125; bst.put(key,val); &#125; for (String key:bst.keys()) &#123; System.out.println("key="+key+",value="+bst.get(key)); &#125; System.out.println(bst.size()); System.out.println(bst.min()); System.out.println(bst.max()); System.out.println(bst.floor("50")); &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java运行时数据区域]]></title>
    <url>%2F2018%2F07%2F03%2Fjava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[运行时数据区域Java虚拟机所管理的内存将会包括一下几个运行时数据区域，如图所示： 程序计数器（线程私有）程序计数器是一块较小的内存空间，它可以看成是当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，各条线程之间计数器相互不影响，独立存储，我们称这类内存区为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器的值为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈（Java VM Stacks）也是线程私有的，它的生命周期和线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 经常有人把Java内存区分为堆内存（heap）和栈内存（stack），这里所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型、对象引用类型（不同于对象本身），局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。 这个区域规定了两种异常：StackOverflowError，线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError,虚拟机栈扩展时无法申请到足够的内存。 本地方法栈（为Native方法服务）虚拟机使用到的Native方法服务的。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆（所有线程共享，存放对象实例）Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配空间。 Java堆是垃圾收集器管理的主要区域。 从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还细分为：新生代和老生代。再细致一点的有：Eden空间，From Survivor空间、To Survivor空间等。 当前主流的虚拟机都是按照可扩展来实现的（-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出OutOfMemoryError。 方法区也是各个线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 很多习惯在HotSpot虚拟机上开发部署的程序开发者习惯把方法区称为“永生代（Permanent Generation）”。本质上并不等价。仅仅是因为HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，或者说使用永生代来实现方法区而已。 使用永生代来实现方法区，容易遇到内存溢出的问题，因为永生代有-XX:MaxPermSize的上限。 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配的需求时，会抛出OutOfMemoryError异常。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table）,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。 直接内存（堆外内存）不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常。 NIO，就可以使用堆外内存。 受到本机总内存大小以及处理器寻址空间的限制。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发布博文，添加图片]]></title>
    <url>%2F2018%2F07%2F03%2Fhexo-add-image%2F</url>
    <content type="text"><![CDATA[方法一这个方法并不是很满意，采用的是方法二 以下是具体步骤： 1.修改hexo博客项目根目录_config.yml配置文件post_asset_folder项为true。 2、安装插件，在博客项目根目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 2.hexo new “new blog”,新建一篇博客。 3.在source/_post文件夹里面就会出现一个“new-blog.md”的文件和一个“new-blog”的文件夹。 4、将图片复制到这个文件夹下，例如test.png 5.引用图片： 方法二在github上建立一个仓库，专门用来存放图片。将需要的图片上传到这个仓库 用以下的方式引入图片1![Alt text](/path/to/img.jpg &quot;Optional title&quot;)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git submodule foreach git pull的问题]]></title>
    <url>%2F2018%2F07%2F03%2Fgit%20submodel%20foreach%20pull%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[git 执行 git submodule foreach git pull的时候，总是报下面的问题 123456789 $ git submodule foreach git pullEntering 'themes/next'You are not currently on a branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;Stopping at 'themes/next'; script returned non-zero status. 后来进到子模块的目录下，执行 git status发现123$ git statusHEAD detached from 395bcfcnothing to commit, working tree clean 貌似生成了一个临时的branch，执行git branch -v1234zhuhaijun@ZhuHaijun-PC MINGW64 /f/myblog/themes/next ((63a1dd2...))$ git branch -v* (HEAD detached from 395bcfc) 63a1dd2 modified master 395bcfc [behind 2] Update ISSUE_TEMPLATE.md 发现现在那个63a1dd2分支上。 解决办法：直接用git checkout master切回master br吧，然后别忘了用git reset --hard 63a1dd2 命令切到最新的hash啊。]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F07%2F02%2FHeap-sort%2F</url>
    <content type="text"><![CDATA[二叉堆定义定义：当一颗二叉树的每个几节点都大于等于它的子节点时，它被称为堆有序。 定义：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（a[0]不使用。）在位置k的节点的父节点位置为k/2 ；位置k的节点的左右子节点分别是 2k,2k+1; 插入元素、删除元素比较大小 交换123456789private boolean less (int i , int j)&#123; return pq[i].compareTo(pq[j]) &lt; 0 ;&#125;private void exch(int i , int j)&#123; T t =pq[i]; pq[i] = pq[j]; pq[j] = t ;&#125; 插入元素将新元素添加到数组的尾，增加堆的大小，并让这个元素上浮到合适的位置 上浮算法：123456private void swim(int k)&#123; while( k &gt; 1 &amp;&amp; less( k/2 , k ))&#123; exch(k/2,k); k = k/2 ; &#125;&#125; 删除最大元素我们删除a[0],并将数组的最后一个元素放到顶端，减小堆的大小，并将这个元素下沉到合适的位置 下沉算法：1234567891011121314private void sink(int k)&#123; while ( 2*k &lt;= N )&#123;//N为数组长度 int j = 2*k ; //比较左右子节点哪个大，取大的那个 if (j &lt; N &amp;&amp; less(j , j +1 )) &#123; j++; &#125; if (!less(k,j)) &#123; break; &#125; exch(k, j); k = j ; &#125;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class HeapSort &#123; public static void main(String[] args) &#123; String a [] = &#123;"S","O","R","T","E","X","A","M","P","L","E"&#125;; sort(a); System.out.println(isSorted(a)); show(a); &#125; public static void sort(Comparable[] a)&#123; int N = a.length; for ( int k = N / 2 ; k &gt;= 1 ; k-- )&#123; //从最后一个子树开始 sink( a ,k , N ); &#125; //此时，最大的元素在根节点 //从根节点开始，将最大的元素依次交换到最后 while (N &gt; 1 )&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; /** * 将a[i] 到 a[j] 之间的元素排序 */ private static void sink(Comparable[] a , int k , int n )&#123; while( 2 * k &lt;= n )&#123; int j = 2 * k ; if (j &lt; n &amp;&amp; less(a,j , j +1))&#123; j++; //寻找两个子几点中大的那个 &#125; if (!less(a,k,j))&#123; //如果父结点比大的那个子结点大。循环结束 break; &#125; exch(a,k ,j); //交换 k = j ; //下沉一级 &#125; &#125; private static void exch(Comparable[] a ,int i,int j)&#123; Comparable t = a[i-1]; a[i-1] = a[j-1]; a[j-1] = t; &#125; private static boolean less(Comparable[] a,int i,int j)&#123; return a[i-1].compareTo(a[j-1]) &lt; 0 ; &#125; private static void show(Comparable[] a)&#123; //单行中打印数组 for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i] + " "); &#125; System.out.println(); &#125; public static boolean isSorted(Comparable[] a)&#123; for (int i = 1 ; i &lt; a.length; i++) &#123; if (less(a,i+1 ,i)) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2F2018%2F06%2F27%2Falgorithm-analysis-math%2F</url>
    <content type="text"><![CDATA[数学基础四个定义定义1 如果存在正常数c和n0使得当N&gt;n0时T(N)≤cf(N),则记为T(N)=O(f(N))。 定义2 如果存在正常数c和n0使得当N&gt;n0时T(N)≥cf(N),则记为T(N)=Ω(f(N))。 定义3 T(N)=Θ(h(N))当且仅当T(N)=O(h(N))和T(N)=Ω(h(N))。 定义4 如果对每一正常数c都存在常数n0使得当N&gt;n0时T(N)&lt;cp(N),则T(N)=o(p(N))。有时候也可以说，如果T(N)=O(p(N))且T(N)≠Θ(p(N)),则T(N)=o(p(N))。 这些定义的目的是要在函数间建立一种相对的级别，来比较它们的相对增长率（relative rate of growth） 定义1 T(N)=O(f(N))是说T(N)的增长率小于或等于f(N)的增长率，大O标记法 定义2 T(N)=Ω(f(N))是说T(N)的增长率大于或等于f(N)的增长率 定义3 T(N)=Θ(h(N))是说T(N)的增长率等于h(N)的增长率。 定义4 T(N)=o(p(N))是说T(N)的增长率大于或等于p(N)的增长率，小o标记法 重要法则法则1 如果T1(N)=O(f(N))且T2(N)=O(g(N))，那么 (a): T1(N) + T2(N) = O( f(N)+g(N) )(直观地和非正式地可以写成max( O(f(N), O(g(N)) ) ) 。 (b): T1(N) T2(N) = O( f(N)g(N) ) 。 法则2 如果T(N)是一个k次多项式，则T(N)=Θ(Nk) 法则3 对任意常数k，logkN = O(N),它告诉我们对数增长得非常缓慢 注意：1、不要将常数或低阶项放进大O。2、我们总能够通过计算极限 $$ limN-&gt;∞f(N)/g(N)来确定两个函数的相对增长率。 运行时间计算要做的就是计算大O运行时间。大O是一个上界。 一般法则法则1——for循环一个for循环的运行时间至多是该for循环内部那些语句的运行时间乘以迭代的次数。 法则2——嵌套for循环在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有for循环的大小的乘积。 法则3——顺序语句将各个语句的运行时间求和即可。 法则4——if/else语句一个if/else语句的运行时间从不超过判断的运行时间再加上if和else中运行时间长者的总的运行时间。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile and synchronized]]></title>
    <url>%2F2018%2F06%2F22%2Fvolatile-and-synchronized%2F</url>
    <content type="text"><![CDATA[volatile概述volatile是轻量级的synchronized,在多处理器开发中保证了共享变量的可见性。可见性：当一个线程修改一个共享变量时，另一个线程能够读到这个修改的值。volatile不会引起线程的上下文切换和调度。 如果一个字段被声明为volatile,Java线程内存模型确保所有线程看到这个变量的值是一致的。 CPU术语定义 内存屏障（memory barriers）：是一组处理器命令，用于实现对内存操作的顺序限制 缓冲行（cache line）：CPU高速缓存中可以分配的最小存储单位 。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令 原子操作(atomic operations):不可中断的一个活或一些列操作 缓存行填充(cache line fill):当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1、L2、L3的或所有） 缓存命中（cache hit）:如果进行高速缓存行填充的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取 写命中（write hit）：当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中 写缺失（write misses the cache）：一个有效的缓存行被写入到不存在的内存区域 volatile实现原理有volatile修饰的共享变量进行写操作的时候，会多出有Lock前缀的指令： Lock前缀指令会引起处理器缓存写回到内容 执行指令期间，声言处理器的LOCK#信号，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存 一个处理器的缓存写回到内存会导致其他处理器的缓存无效 处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致 synchronizedsynchronized实现同步的基础：Java中每一个对象都可以作为锁，具体表现为以下3种形式： 对于普通同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是synchronized括号里配置的对象 synchronized在JVM里的实现原理是， JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。monitorenter指令在编译后插入到同步代码块的开始位置，monitorexit是插入到方法结束和异常处。线程执行到monitorexter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 Java对象头synchronized用的锁是存在Java对象头里的Mark Word。Java对象头的长度 长度 内容 说明 32/64bit Mark Word 存储对象的hashCode或锁信息等 32/64bit Class Metadata Addredd 存储到对象类型数据的指针 32/64bit Array length 数组的长度（如果当前对象是数组） 锁的升级与对比锁一共4种状态，级别从低到高依次是： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 偏向锁对于经常由同一线程多次获得锁的情况，为了让线程获得锁的代价更低，引入偏向锁。偏向锁会在对象头和栈帧中的锁记录存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>volatile synchronized concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2F2018%2F06%2F22%2Fmarkdown-grammar%2F</url>
    <content type="text"><![CDATA[Headers标题12345678910111213# H1## H2### H3#### H4##### H5###### H6另外，H1和H2还能用以下方式显示：一级标题===二级标题--- Emphasis 文本强调123*斜体* or _强调_**加粗** or __加粗__***粗斜体*** or ___粗斜体__ Lists 列表12345678910111213141516171819202122232425262728293031323334353637Unordered 无序列表：* 无序列表* 子项* 子项+ 无序列表+ 子项+ 子项- 无序列表- 子项- 子项Ordered 有序列表：1. 第一行2. 第二行3. 第三行1. 第一行- 第二行- 第三行组合：* 产品介绍（子项无项目符号） 此时子项，要以一个制表符或者4个空格缩进* 产品特点 1. 特点1 - 特点2 - 特点3* 产品功能 1. 功能1 - 功能2 - 功能3可有时我们会出现这样的情况，首行内容是以日期或数字开头：2013. 公司年度目标。为了避免也被转化成有序列表，我们可以在&quot;.&quot;前加上反斜杠（转义符）：2013\. 公司年度目标。 Links 连接（title为可选项）12345678910111213141516Inline-style 内嵌方式：[link text](https://www.google.com &quot;title text&quot;)Reference-style 引用方式：[link text][id][id]: https://www.mozilla.org &quot;title text&quot;Relative reference to a repository file 引用存储文件：[link text](../path/file/readme.text &quot;title text&quot;)还能这样使用：[link text][][link text]: http://www.reddit.comEmail 邮件：&lt;example@example.com&gt; Images 图片123456Inline-style 内嵌方式：![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &quot;title text&quot;)Reference-style 引用方式：![alt text][logo][logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &quot;title text&quot; 代码使用反引号(esc键下面的按钮)将代码包裹起来 分割线 如果我们想用分割线对内容进行分割，我们可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线。 引用如果我们在文章中引用了资料，那么我们可以通过一个右尖括号”&gt;”来表示这是一段引用内容。我们可以在开头加一个，也可以在每一行的前面都加一个。我们还可以在引用里面嵌套其他的引用 换行在需要换行的地方输入至少两个空格，然后回车即可 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em> 标签），你可以在星号的前面加上反斜杠：\*literal asterisks\*Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是协程]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是进程和线程进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有多个子线程。线程有自己的栈空间。 对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。 Java中线程具有五种状态 初始化 可运行 运行中 阻塞 销毁 JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程状态，这一过程需要消耗一定的CPU资源。 什么是协程协程，英文Coroutines，是一种比线程更加轻量级的存在。一个线程可以拥有多个协程。协程不是被操作系统内核所管理，而完全由程序所控制（也就是用户态执行）。 协程的暂停和线程的阻塞是有本质的区别的。协程的暂停完全是由程序控制，线程的阻塞状态是由操作系统内核来进行切换。 因此，协程的开销远远小于线程的开销。 协程的应用Java语言并没有对协程的原生支持，不过某些开源框架模拟出协程的功能。例如Kilim ， https://github.com/kilim/kilim Python可以通过yield/send的方式实现协程，在python3.5以后，async/await成为了更好的替代方案 Go语言支持]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 并发 线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到底部上滑加载更多]]></title>
    <url>%2F2018%2F06%2F21%2Floadmore%2F</url>
    <content type="text"><![CDATA[到底部，上滑加载更多123456789101112131415161718192021var loading = false ;$(window).on('scroll',function()&#123; if(scrollTop() + windowHeight() &gt;= documentHeight())&#123; loadMore(); &#125;&#125;);//上滑加载$(window).bind("scroll", $.debounce(200, function() &#123; loadMore()&#125;));function loadMore() &#123; if (document.body.scrollTop + $(window).height() &gt; $(document).height() - 200) &#123; if (isloading) return; isloading = true; //loadMore的逻辑 &#125; &#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js loadmore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js timestamp 转化为时间字符串]]></title>
    <url>%2F2018%2F06%2F21%2Fjs-timestamp-to-datestring%2F</url>
    <content type="text"><![CDATA[js的时间戳转化为时间字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 时间格式方法 * @param &#123;any&#125; timeStamp 时间戳，秒级/毫秒级 * @param &#123;any&#125; type 格式化时间类型，默认 Y-M-D H:I:S * @returns &#123;string&#125; formatTime 格式化后的时间 例如： 2017-05-05 12:09:22 */function formatDate(timeStamp, type = 'Y-M-D H:I:S zh', auto = false) &#123; let time = (timeStamp + '').length === 10 ? new Date(parseInt(timeStamp) * 1000) : new Date(parseInt(timeStamp)); let _year = time.getFullYear(); let _month = (time.getMonth() + 1) &lt; 10 ? '0' + (time.getMonth() + 1) : (time.getMonth() + 1); let _date = time.getDate() &lt; 10 ? '0' + time.getDate() : time.getDate(); let _hours = time.getHours() &lt; 10 ? '0' + time.getHours() : time.getHours(); let _minutes = time.getMinutes() &lt; 10 ? '0' + time.getMinutes() : time.getMinutes(); let _secconds = time.getSeconds() &lt; 10 ? '0' + time.getSeconds() : time.getSeconds(); let formatTime = ''; let distinctTime = new Date().getTime() - time.getTime(); if (auto) &#123; if (distinctTime &lt;= (1 * 60 * 1000)) &#123; // console.log('一分钟以内，以秒数计算'); let _s = Math.floor((distinctTime / 1000) % 60); formatTime = _s + '秒前'; &#125; else if (distinctTime &lt;= (1 * 3600 * 1000)) &#123; // console.log('一小时以内,以分钟计算'); let _m = Math.floor((distinctTime / (60 * 1000)) % 60); formatTime = _m + '分钟前'; &#125; else if (distinctTime &lt;= (24 * 3600 * 1000)) &#123; // console.log('一天以内，以小时计算'); let _h = Math.floor((distinctTime / (60 * 60 * 1000)) % 24); formatTime = _h + '小时前'; &#125; else if (distinctTime &lt;= (30 * 24 * 3600 * 1000)) &#123; let _d = Math.floor((distinctTime / (24 * 60 * 60 * 1000)) % 30); formatTime = _d + '天前'; // console.log('30天以内,以天数计算'); &#125; else &#123; // 30天以外只显示年月日 formatTime = _year + '-' + _month + '-' + _date; &#125; &#125; else &#123; switch (type) &#123; case 'Y-M-D H:I:S': formatTime = _year + '-' + _month + '-' + _date + ' ' + _hours + ':' + _minutes + ':' + _secconds; break; case 'Y-M-D H:I:S zh': formatTime = _year + '年' + _month + '月' + _date + '日 ' + _hours + ':' + _minutes + ':' + _secconds; break; case 'Y-M-D H:I': formatTime = _year + '-' + _month + '-' + _date + ' ' + _hours + ':' + _minutes; break; case 'Y-M-D H': formatTime = _year + '-' + _month + '-' + _date + ' ' + _hours; break; case 'Y-M-D': formatTime = _year + '-' + _month + '-' + _date; break; case 'Y-M-D zh': formatTime = _year + '年' + _month + '月' + _date + '日'; break; case 'Y-M': formatTime = _year + '-' + _month; break; case 'Y': formatTime = _year; break; case 'M': formatTime = _month; break; case 'D': formatTime = _date; break; case 'H': formatTime = _hours; break; case 'I': formatTime = _minutes; break; case 'S': formatTime = _secconds; break; default: formatTime = _year + '-' + _month + '-' + _date + ' ' + _hours + ':' + _minutes + ':' + _secconds; break; &#125; &#125; // 返回格式化的日期字符串 return formatTime;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件内容查阅]]></title>
    <url>%2F2018%2F05%2F14%2Flinux-view-file%2F</url>
    <content type="text"><![CDATA[文件内容查看cat由第一行开始显示文件内容cat [-AbEntv]-A：相当于-vET，可以列出一些特殊字符，而不是空白而已-b：列出行号，仅针对非空白行做行号显示，空白行不标行号-E：将结尾的断行字符$显示出来-n：打印出行号，空白行也打印-T：将Tab按键以^I 显示出来-v：列出一些看不见的特殊字符 tac将cat反向显示，由最后一行到第一行反向在屏幕上显示出来 nl添加行号打印nl [-bnw] 文件-b：指定行号指定的方式，只要有2种 -b a：不论是否为空行，也同样列出行号 -b t： 如果有空行，空的那行不列出（默认）-n：列出行号的方法 -n ln：行号在屏幕的最左方显示 -n rn：行号在自己字段的最右方显示，且不加0 -n rz：行号在自己字段的最右方显示，加0-w：行号字段占用的位数 more一页一页翻动+n：从第n行开始显示-n：定义屏幕大小为n行-c：顶部清屏，然后显示+/字符串：先搜索字符串，然后从字符串之后开始显示 常用操作：空格键Space： 向下翻动一页Enter： 向下滚动一行/字符串： 向下查询“字符串”这个关键字:f： 立即显示出文件名以及目前显示的行数q： 立即离开moreb或ctrl+b：代表往回翻页，只对文件有效，对管道无效ctrl+f：向下翻页=：输出当前行的行号V：调用vi编辑器 less一页一页翻动，可以往前往后翻动-i：搜索的时候忽略大小写-m：显示百分比 常用操作：y：向上翻动一行Enter： 向下滚动一行空格键： 向下翻动一页PageDown：向下翻动一页PageUp：向上翻动一页/字符串：向下查询?字符换：向上查询n：重复前一个查询（与/或?有关）N：反复重复前一个查询 （与/或?有关）q：离开less这个程序 head取出前面几行-n number：取出前面number 行+number：从第几行开始列出 tail取出后面几行-n number：取出后面几行-f：表示持续检测后面所街的文件名 od读取执行文件，通常是二进制文件od [-t TYPE] 文件-t ：后面可以接各种“类型”的输出 a：利用默认的字符来输出 c：利用ASCII字符输出 d[size]：利用十进制来输出，每个整数占用size bytes f[size]：利用浮点数来 输出 o[size]：利用八进制来输出 x[size]：利用十六进制来输出 修改文件时间或创建新文件touch修改文件时间或创建新文件modification time（mtime）当文件内容改变了，会更新这个时间 （默认显示）status time（ctime）当文件的状态（权限、属性）改变了，会更新这个时间access time（atime）当文件的内容被取用，会更新这个读取时间例如：ls -l –time=atime /etc/man.config 查看这个文件的读取时间touch [-acdmt] 文件-a：仅修改访问时间-c：仅修改文件的时间，若文件不存在则不创建新文件-d：后面可以接欲修改的日期而不用当前的日期，-m：仅修改mtime-t：后面可以接欲修改的时间，而不用当前的时间，格式为YYMMDDhhmm 文件查找which寻找“执行文件”-a：将所有由PATH目录中可以找到的命令均列出，而不只第一个被找到的命令名称。which并不能找到cd命令，因为cd是bash内置的命令，但是which默认是查找PATH内所规范的目录。 whereis寻找特定文件whereis [-bmsu] 文件或目录名-b：只找二进制格式的文件-m：只找在说明文件manual路径下的文件-s：只找source源文件-u：查找不在上述三个选项当中的其他特性文件 Linux系统会将系统内的所有文件都记录在一个数据库文件里面，而当使用whereis或者locate命令时，都会以此数据库文件的内容为准。locate寻找的数据是由已创建的数据库/var/lib/mlocate里面的数据所查找到的，所以很快速。更新locate数据库的方式，“updatedb” updatedb根据/etc/updatedb.conf的设置去查找系统硬盘内的文件名，并更新/var/lib/mlocate内的数据库文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux，cat</tag>
        <tag>more</tag>
        <tag>less</tag>
        <tag>touch</tag>
        <tag>which</tag>
        <tag>whereis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPM、SRPM与YUM 常用命令]]></title>
    <url>%2F2018%2F05%2F14%2Flinux-rpm-srpm-yum%2F</url>
    <content type="text"><![CDATA[rpmrpm 安装（install）rpm -ivh package-name 参数： -i：install的意思 -v：查看更详细的安装信息画面 -h：以安装信息栏显示安装进度 rpm 升级与更新（upgrade/freshen）以-Uvh 或 -Fvh 来升级 -Uvh：后面接的软件即使没有安装过，则系统将予直接安装，若安装过，则系统自动更新到新版 -Fvh：后面接的软件并未安装到你的Linux系统上，则该软件不会被安装。 rpm 查询（query）RPM在查询的时候，其实查询的地方是/var/lib/rpm这个目录下的数据库文件 rpm -qa &lt;==已安装软件 rpm -q[licdR] 已安装软件的名称 &lt;== 已安装软件 rpm -qf 存在于系统上面的某个文件名 &lt;==已安装软件 rpm -qp[licdR] 未安装的某个文件名称 &lt;== 查阅RPM文件 参数：查询已安装软件的信息 -q：仅查询，后面接的软件名称是否有安装 -qa：列出所有的已经安装在本机Linux系统上面的所有软件名称 -qi：列出该软件的详细信息，包含开发商，版本与说明等 -ql：列出该软件所有的文件与目录所在的完整文件名（list） -qc：列出该软件的所有设置文件（找出在/etc/下面的文件名而已） -qd：列出该软件的所有帮助文档（找出与man有关的文件而已） -qR：列出与该软件有关的依赖软件所含的文件名（Required的意思） -qf：由后面接的文件名称找出该文件属于哪一个已安装的软件 -qp[licdR]：后面接的所有的参数以上面的说明一致，但用途仅在于找出某个RPM文件内的信息 rpm 验证与数字证书（Verify/Signature）rpm -Va rpm -V 已安装的软件名称 rpm -Vp 某个RPM文件的文件名 rpm -Vf 在系统上面的某个文件 参数： -V：后面加的是软件名称，若该软件所含的文件被改动过，才会列出来 -Va：列出目前系统上面所有可能被改动过的文件 -Vp：后面接的是文件名称，列出该软件内可能被改动过的文件 -Vf：列出某个文件是否被改动过 rpm 卸载rpm -e 软件名称 重建数据库rpm –rebuilddb srpm文件的安装rpmrebuild --rebuild src-package-name —–&gt; 将后面的SRPM进行编译与打包，最后产生RPM的文件（仅编译并打包） rpmrebuild --recompile src-package-name —–&gt; 直接编译、打包并且安装（不仅进行编译打包，还进行安装） yumyum查询功能 yum [ list | info | search | provides | whatprovides ] 参数yum [option] [查询工作项目] [相关参数] 参数: [option]：主要的参数，包括有： -y：当yum要等待用户输入时，这个选项可以自动提供yes的响应 –installroot=/some/path ： 将该软件安装在 /some/path 中而不适用默认路径 [查询工作目录] [相关参数] ：这方面的参数有： search：搜索某个软件名称或者是描述（description）的重要关键字 list：列出目前yum所管理的所有的软件名称与版本，有点类似于rpm -qa info：同上，类似于rpm -qai 的运行结果 provides：从文件中去搜索软件，类似于 rpm -qf的功能 例子： yum search raid：搜索磁盘阵列（raid）相关的软件有哪些 yum info mdadm ： 找出mdadm这个软件的功能为何 yum list updates ： 列出目前服务器上可供本机进行升级的软件有哪些 yum provides passwd：列出提供passwd这个文件的软件有哪些 yum安装/升级功能：yum [install | update] 软件yum [option] [查询工作项目] [相关参数]参数：install：后面接要安装的软件update：后面接要升级的软件，若要整个系统都更新，就直接 update 即可 yum删除功能：yum [ remove ] 软件yum的设置文件vi /etc/yum.repos.d/CentOS-Base.repo 列出目前 yum server 所使用的容器有哪些yum repolist all yum的软件组功能yum [组功能] [软件组] 参数： grouplist：列出所有可使用的组列表，例如Development Tools之类的 groupinfo：后面接group name，则可了解该group内含的所有组名称 groupinstall：可以安装一整组软件 groupremove：移除某个组 例如： yum groupinstall “Development Tools” 安装开发软件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linix</tag>
        <tag>rpm</tag>
        <tag>srpm</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux vim操作说明]]></title>
    <url>%2F2018%2F05%2F14%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[vi与vimvi分为3个模式： 一般模式：默认模式，可以上下左右按键移动光标，可以删除字符或删除整行，可以复制、粘贴编辑模式：按下“i,I,o,O,a,A,r,R”等任一字母进入编辑模式，按Esc退出到一般模式命令行模式：一般模式下，输入“：、/、?”三个中任一个按钮 移动光标的方法 按键 描述 h或左箭头键 向左移动一个字符 j或下 向下移动一个字符 k或上 向上移动一个字符 l或右 向右移动一个字符 先按数字，再按上下左右 移动多个字符 Ctrl+f 屏幕下移一页 相当于 PgDn键 Ctrl+b 屏幕上移一页，相当于PgUp键 Ctrl+d 屏幕向下移动半页 Ctrl+u 屏幕向上移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n space 按下数字，再按空格，光标会向右移动这一行的n个字符 0 或 Home 移动到这一行最前面 $ 或 End 移动到这一行最后面 H 光标移动到这个屏幕最上方那一行的第一个字符 M 光标移动到这个屏幕的中央的那一行的第一个字符 L 光标移动到这个屏幕最下方第一行的第一个字符 G 移动到这个文件的最后一行 nG 移动到这个文件的第n行 gg 移动到这个文件的第一行，1G n Enter 向下移动n行 查找和替换 按键 描述 /word 向下查找一个word字符串 ?word 下上查找一个word字符串 n n是英文按键，代表重复前一个查找 N “反向”进行前一个查找操作 :n1,n2s/word1/word2/g n1、n2为数字，在第n1和n2行之间查找word1，并替换为word2 :1,$s/word1/word2/g 第一行到最后一行之间，查找并替换 :1,$s/word1/word2/gc 替换之前，显示提示符，让用户确认 删除、复制与粘贴 按键 描述 x,X 在一行中，x为向后删除一个字符，X为向前删除一个常用字符 nx n为数字，连续向后删除n个字符 dd 删除光标所在行 ndd 删除光标所在的向下n行 d1G 删除光标所在行到第一行的所有数据 dG 删除光标所在行到最后一行的所有数组 d$ 删除从光标所在处到该行的最后一个字符 d0 删除从光标所在处到该行的第一个字符 yy 复制光标所在行 nyy 复制光标所在的向下n行 y1G 复制光标所在行到第一行的数据 yG 复制光标所在行到最后一行 y$ 复制光标所在处到行尾的所有数据 y0 复制光标所在处到行首的所有数据 p，P p为将已复制的数据在光标的下一行粘贴P为将已复制的数据在光标的上一行粘贴 J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除10行，【10cj】 u 复原前一个操作 Ctrl+r 重做上一个操作 . 小数点，重复上一个操作 一般模式切换到编辑模式的可用按钮说明 按键 描述 i,I 进入插入模式i为从目前光标所在处插入，I为在目前光标所在行的一个非空格符处开始插入 a，A 进入插入模式a为从目前光标所在的下一个字符出开始插入，A为从光标所在行的最后一个字符处开始插入 o，O 进入插入模式o为在光标所在行的下一行插入新的一行O为在目前光标所在行的上一行插入一行 r，R 进入替换模式r只会替换光标所在的字符一次R会一直替换光标所在的字符，只要按下Esc 一般模式切换到命令行模式的可用按钮说明 按键 描述 :w 保存，将编辑的数据写入硬盘中 :w! 强行保存，是否可以写入与权限有关 :q 离开vi :q! 强制离开不保存 :wq 保存后离开，：wq!则为强行保存后离开 ZZ 若文件没有更改，则不保存离开，若文件更改了，则保存后离开 :w [filename] 将编辑的数据保存为另一个文件（类似于另存为文件） :r [filename] 将“filename”这个文件内容加到光标所在行后面 :n1.n2 w [filename] 将n1到n2之间的内容保存为filename这个文件 :! command 暂时离开vi到命令行模式下执行cammand的显示结果 :set nu 显示行号 :set nonu 与set nu相反，取消行号 vim块选择 按键 描述 v 字符选择，会将光标经过的地方反白选择 V 行选择，会将光标经过的行反白选择则 ctrl+v 块选择，可以用长方形的方式选择数据 y 将反白的地方复制 d 将反白的地方删除 多文件编辑 按键 描述 :n 编辑下一个文件 :N 编辑上一个文件 :files 列出目前这个vim打开的所有文件 多窗口功能在命令行模式，输入:sp {filename},filename可有可无如果想在新窗口启动另一个文件，就加入另一个文件的文件名，否则仅输入:sp，出现的是同一个文件在两个窗口打开 按键 描述 :sp {filename} 打开一个新口 Ctrl+w+j，Ctrl+w+下 按键的按法是：先按住Ctrl不放，再按下w后放开所有的键然后在按下j或下，则光标可以移动到下方窗口 Ctrl+w+k,Ctrl+w+上 同上，不过光标移动到上方窗口 Ctrl+w+q 其实就是:q结束离开，关闭下方窗口 vim环境设置在一般模式时，输入“:set all”可以显示环境设置参数 按键 描述 :set nu ， :set nonu 设置与取消行号 :set hlsearch ，:set nohlsearch hlsearch 就是high light search 高亮度查找这个设置就是是否将查找的字符串反白的设置。默认是hlsearch :set autoindent,:set noautoindet 表示是否自动缩排 :set backup 是否自动保存备份文件，一般是nobackup否则，改动任何文件，原文件会另存为一个文件名为filename~的文件 :set ruler 显示或不显示右下角的一些状态 :set showmode 是否要显示 –INSERT–之类的字眼 :set all 显示目前所有的环境参数设置值 :set 显示与系统默认值不同的设置参数 整体vim的设置值一般是放置在/etc/vimrc这个文件中，不过不建议修改它。你可以修改~/.vimrc这个文件（默认不存在，请你自行手动创建）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linix</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过添加git子模块的方式来下载hexo next主题]]></title>
    <url>%2F2018%2F05%2F12%2Fadd-themes-next-by-submodule%2F</url>
    <content type="text"><![CDATA[Fork当我们使用hexo的时候，一般都会使用各种主题，大多数的文档都是叫我们直接clone主题到themes目录下，然后再配置-config.yml。 但是，当我们将我们的博客上传到我们自己的github上的时候，主题无法与博客数据一起同步。 原因是我们使用了clone将主题下载到本地，所以它自己本身也是一个git仓库。因此它上层的博客仓库就无法对其进行管理。 更好的方法是fork一份主题到自己的github上，再将自己的github里的主题当作子模块加载进来。 fork的目的在于，我们可以对主题进行各种个性化的定制以及修改，并对这些定制进行版本控制。同时，我们还能随时与原主题的更新进行合并。 1、fork `git@github.com:iissnan/hexo-theme-next.git` 到自己的github 通过git submodule add 添加为子模块12$ cd your-hexo-site$ git submodule add https://github.com/someone/hexo-theme-next themes/next 运行 git status，会看到1234567$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: .gitmodules new file: themes/next 首先你注意到有一个.gitmodules文件。1234$ cat .gitmodules[submodule "themes/next"] path = themes/next url = https://github.com/iissnan/hexo-theme-next 修改themes/next主题修改了themes/next里面的内容后，git status查看12345678910111213$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: .gitmodules new file: themes/nextChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: .gitmodules modified: themes/next (modified content, untracked content) 更新submodulesubmodule里面做了修改操作后，要在submodule和主目录下分别提交 submodule push 到远端仓库将添加的子模块push到远端submodule的仓库，分别执行123git add .git commit -m '提交信息'git push 主目录内push然后再回到父目录,提交Submodule在父项目中的变动123git add .git commit -m ' update submodule'git push clone Submodule 方法一：一种是采用递归的方式clone整个项目 1git clone git@github.com:***/***.git --recursive 方法二：一种是clone父项目，再更新子项目clone我的博客项目后,执行下面更新命令 123cd your-hexo-sitegit submodule initgit submodule update 更新submodule方法一：在父目录直接执行1git submodule foreach git pull 方法二：在submodule目录下执行1git pull]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>submodule</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多终端同步管理博客]]></title>
    <url>%2F2018%2F05%2F12%2Fhexo-many-computer%2F</url>
    <content type="text"><![CDATA[A电脑备份博客到github 进入博客根目录。确认.gitignore文件的存在。内容如下： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 在博客根目录下，在git bash下依次执行 12git initgit remote add origin &lt;server&gt; 同步到远程git仓库，在git bash下以此执行 123git add . #添加目录下所有文件git commit -m “更新说明” #提交并添加更新说明git push -u origin master #推送更新到远程仓库 B电脑拉下远程仓库文件在B电脑上先安装好nodejs、git、hexo，执行123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 建好hexo文件夹，再执行以下命令：1234git initgit remote add origin &lt;server&gt; #添加远程仓库git fetch --all #从远程仓库抓取数据到本地git reset --hard origin/master #彻底回退到某个版本，本地的源码也会变为上一个版本的内容 然后同步submodule，更新themes下的主题123cd you-hexo-sitegit submodule initgit submodule update B电脑发布博客后同步在B电脑发布完博客之后，将博客备份同步到远程仓库。执行以下命令：123git add #可以用git master 查看更改内容git commit -m "更新信息"git push -u origin master #以后每次提交可以直接git pu 每次写博客时同步管理每次写博客之前，先执行12git pullgit submodule foreach git pull 进行同步更新。发布完文章后同样按照上面的发布博客后同步。 同步到远程仓库。 常用命令整理12345678git pull #同步更新github仓库hexo new "文章名" #简写形式 hexo n "文章名"hexo clean #清除旧的public文件夹hexo generate #生成静态文件 简写形式 hexo ghexo deploy #发布到github上 简写形式 hexo dgit add . #添加更改文件到缓存区git commit -m "更新说明" #提交到本地仓库git push -u origin master #推送到远程仓库进行备份]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装并使用hexo]]></title>
    <url>%2F2018%2F05%2F12%2Finstall-hexo%2F</url>
    <content type="text"><![CDATA[安装HexoHexo是一个快速、简洁、高效的博客框架。Hexo使用Markdown解析文章。可以快速生成靓丽的主题的静态网页。 Hexo参考文档：https://hexo.io/zh-cn/docs/ 安装前提安装Hexo前，确保您的电脑里已经安装了 node.js git 如果你的电脑已经安装了上述必备程序，那么接下来只需要使用npm即可完成hexo的安装。1$ npm install -g hexo-cli 安装gitgit参考文档：https://git-scm.com/book/zh/v2 由于我们写博客一般都在windows系统上面，这里只写一下windows环境安装过程。 Linux下安装参考上面的文档。 点击https://git-scm.com/download/win,会自动下载安装程序，点下一步下一步就可以了。 安装node.jswindows下64位下载地址：http://nodejs.cn/download/ 下载后 一直点下一步下一步即可。 安装完成后，cmd中输入path。我们可以看到环境变量中已经包含了C:\Program Files\nodejs\ 安装hexo1$ npm install -g hexo-cli 建站安装后，执行下面的命令，Hexo将会在指定的文件夹中新建所需的文件。123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 如果没有输入folder，则是在当前目录中新建。 新建完成后，目录结构如下所示12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 使用hexo新建文章1$ hexo new "My New Post" #可以简写成hexo n 生成静态网页12$ hexo generate$ hexo g #可以简写成hexo g 启动服务123$ hexo server$ hexo s #可以简写成hexo #!/bin/sh$ hexo s --debug 启动完以后，可以通过 127.0.0.1:4000 访问 部署到远程服务器上12$ hexo deploy$ hexo d #可以简写成hexo d 注：通过配置github pages的地址到_config.yml中，执行这条命令后，可以一键部署到github pages。 部署到github上需要安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 清理1$ hexo clean]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Atom编辑Markdown]]></title>
    <url>%2F2018%2F05%2F10%2Fatom%2F</url>
    <content type="text"><![CDATA[atom工欲善其事必先利其器，找到一款好用的编辑器Atom。通过下载插件，可以用来编辑Markdown文本 1、安装Atom下载地址：https://atom.io/ Ctrl + Shift + P 可以调出快捷键 2、安装插件File –&gt; Setting –&gt; Install –&gt; Search for package输入插件名，即可安装 markdown 好用的插件1、增强预览插件（markdown-preview-plus）atom自带的Markdown预览插件markdown-preview功能比较简单，markdown-preview-plus做了功能扩展和增加。 支持预览实时渲染（ Ctrl + Shift + M ） 支持Latex公式（ Ctrl + Shift + X ） 2、粘贴图片 markdown-image-paste 截图到剪切板 在Markdown新起一行输入文件名 Ctrl+V 会自动把图片保存到Markdown文件的相同目录下 3、表格编辑插件markdown-table-editor使用方法： 先输入一个 | 和一些内容，按tab键，即可移动到下一列 按enter键，移动到下一行 按esc键，结束编辑表格 Commands: Commands Description Keybinding Next Cell Move to next cell tab Previous Cell Move to previous cell shfit+ tab Next Row Move to next row enter Escape Escape from the table esc 如果你添加一些快捷键到你的 keymap.cson1234567891011121314151617'atom-text-editor:not(.mini):not(.autocomplete-active).markdown-table-editor-active': 'ctrl-left' : 'markdown-table-editor:move-left' 'ctrl-right' : 'markdown-table-editor:move-right' 'ctrl-up' : 'markdown-table-editor:move-up' 'ctrl-down' : 'markdown-table-editor:move-down' 'shift-ctrl-left' : 'markdown-table-editor:align-left' 'shift-ctrl-right' : 'markdown-table-editor:align-right' 'shift-ctrl-up' : 'markdown-table-editor:align-center' 'shift-ctrl-down' : 'markdown-table-editor:align-none' 'alt-shift-ctrl-left' : 'markdown-table-editor:move-column-left' 'alt-shift-ctrl-right': 'markdown-table-editor:move-column-right' 'alt-shift-ctrl-up' : 'markdown-table-editor:move-row-up' 'alt-shift-ctrl-down' : 'markdown-table-editor:move-row-down' 'ctrl-k ctrl-i' : 'markdown-table-editor:insert-row' 'ctrl-k alt-ctrl-i' : 'markdown-table-editor:delete-row' 'ctrl-k ctrl-j' : 'markdown-table-editor:insert-column' 'ctrl-k alt-ctrl-j' : 'markdown-table-editor:delete-column' 4、代码增强language-markdown打开一个 Markdown 文件，按ctrl+shift+L选择“Markdown” 5、Markdown Maker]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached启动与查看状态]]></title>
    <url>%2F2018%2F05%2F10%2Fmemcached-stats%2F</url>
    <content type="text"><![CDATA[##启动memcached1memcached -d -p 11311 -u odin -m 512 -c 1024 -p 设置TCP端口号，默认为11211-U 设置UDP端口号-u 指定用于运行进程的用户-m 允许的最大内存量，单位是M，默认是64M-c 最大连接数,默认为1024 连接memcached 和退出12telnet 127.0.0.1 11211quit stats查看状态示例如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253STAT pid 22459 进程IDSTAT uptime 1027046 服务器运行秒数STAT time 1273043062 服务器当前unix时间戳STAT version 1.4.4 服务器版本STAT libevent 2.0.21-stableSTAT pointer_size 64 操作系统字大小(这台服务器是64位的)STAT rusage_user 0.040000 进程累计用户时间STAT rusage_system 0.260000 进程累计系统时间STAT curr_connections 10 当前打开连接数STAT total_connections 82 曾打开的连接总数STAT connection_structures 13 服务器分配的连接结构数STAT reserved_fds 20STAT cmd_get 54 执行get命令总数STAT cmd_set 34 执行set命令总数STAT cmd_flush 3 指向flush_all命令总数STAT get_hits 9 get命中次数STAT get_misses 45 get未命中次数STAT delete_misses 5 delete未命中次数STAT delete_hits 1 delete命中次数STAT incr_misses 0 incr未命中次数STAT incr_hits 0 incr命中次数STAT decr_misses 0 decr未命中次数STAT decr_hits 0 decr命中次数STAT cas_misses 0 cas未命中次数STAT cas_hits 0 cas命中次数STAT cas_badval 0 使用擦拭次数STAT touch_hits 0STAT touch_misses 0STAT auth_cmds 0STAT auth_errors 0STAT bytes_read 15785 读取字节总数STAT bytes_written 15222 写入字节总数STAT limit_maxbytes 67108864 分配的内存数（字节）STAT accepting_conns 1 目前接受的链接数STAT listen_disabled_num 0STAT time_in_listen_disabled_us 0STAT threads 4 线程数STAT conn_yields 0STAT hash_power_level 16STAT hash_bytes 524288STAT hash_is_expanding 0STAT malloc_fails 0STAT conn_yields 0STAT bytes 0 存储item字节数STAT curr_items 0 item个数STAT total_items 34 item总数STAT expired_unfetched 0STAT evicted_unfetched 0STAT evictions 0 为获取空间删除item的总数STAT reclaimed 0STAT crawler_reclaimed 0STAT crawler_items_checked 0STAT lrutail_reflocked 0 获取运行状态1echo stats | nc 127.0.0.1 11211 也可以查看到 stats 查看memcached的连接数1netstat -nat | fgrep 11211 |awk '&#123;print $4&#125;' | fgrep 11211 | wc -l]]></content>
      <categories>
        <category>memcached</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取hadoop权威指南第四版中的NCDC数据]]></title>
    <url>%2F2018%2F05%2F08%2Fget-hadoop-ncdc-data%2F</url>
    <content type="text"><![CDATA[美国国家气候数据NCDC的FTP地址为:ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2013/ 可以通过以下shell脚本来获得1vim getNcdcBigData.sh 内容如下：123456#!/bin/bashfor i in &#123;1901..2014&#125;docd /home/xxxx/hapood/ncdcwget --execute robots=off -r -np -nH --cut-dirs=4 -R index.html* ftp://ftp.ncdc.noaa.gov/pub/data/gsod/$i/done]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>ncdc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中svn “out of date”解决办法]]></title>
    <url>%2F2018%2F05%2F03%2Fsvn-out-of-date%2F</url>
    <content type="text"><![CDATA[svn出现out of date的错误，通过以下三步，即可解决。 team -&gt; update team -&gt; Show Tree Confict team -&gt; commit]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始]]></title>
    <url>%2F2018%2F04%2F28%2Fstart%2F</url>
    <content type="text"><![CDATA[经过了一天的摸索，终于通过hexo+github搭建好了我的个人博客，并且下载了next主题，并且做了一些优化。希望以后可以将自己的所见所想，学习的总结记录于此。业精于勤！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
